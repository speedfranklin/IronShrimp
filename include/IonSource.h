//
//                  W A R N I N G:  DO NOT MANUALLY MODIFY THIS FILE
//                  ------------------------------------------------
//
// This file has been automatically generated by Codalogic's LMX W3C Schema to 
// C++ compiler.  
//
// It should not be manually modified as this may cause the code to break, or 
// operate in unexpected ways.
// 
// To change the contents of this file, modify the schema, and then re-compile.

//                 Copyright (c) 2019 Codalogic Ltd.
//
// See the LMX license agreement for restrictions on the use of this file.

// THIS FILE AND THE SOFTWARE CONTAINED HEREIN IS PROVIDED "AS IS", WITHOUT
// WARRANTY OF ANY KIND.
//
// CODALOGIC LTD SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY ANYONE
// OR ANYTHING DUE TO THE USE OF THIS FILE HOWEVER THEY MAY BE CAUSED.
//
// For more information on the LMX compiler, go to:
// 
//     http://www.xml2cpp.com
//
// Also see:
//
//     http://www.codalogic.com
//

// TargetNamepsace: 
// Source File: IonSource.xsd
// LMX Version: 7.2
// Compile options: -autover2 -local-enums -ns-map-base IonSource_ -prefix-enum IonSource_ -no-ev -no-gen-date -no-html -no-root-class -include-h AdvionObjects.h -snippets -output-defaults -cns AdvionObjects IonSource.xsd ..\\..\\cpp\\AdvionObjects\\IonSource

// License details (This file is not valid without this information)
//     License number: 1322669991
//     License owning company: Advion, Inc
//     License owning e-mail addr: trumborb@advion.com
//     License authorising code: 84a013fdcf68a3d1d4aa36b28356d7f7
//
//       Copyright (c) 2019 Advion, Inc.

#ifndef __ADVIONOBJECTS_IONSOURCE_H__
#define __ADVIONOBJECTS_IONSOURCE_H__

#if defined( _MSC_VER ) && _MSC_VER >= 1400
#pragma warning (push)
#pragma warning (disable:4100)  // Disable unreferenced formal parameter
#endif

#include "AdvionObjects.h"

#include "lmxuser.h"

// To help MS intellisense
#ifndef LMX_GDECL
#define LMX_GDECL
#endif

namespace AdvionObjects {

LMX_GDECL extern const lmx::s_ns_map IonSource_reader[];
LMX_GDECL extern const lmx::s_ns_map IonSource_writer_1[];

enum
{
    IonSource_error = lmx::EXE_LAST_XML_EVENT,
    IonSource_NONE_ionSourceOptimization,
    IonSource_NONE_version,
    IonSource_NONE_negative,
    IonSource_NONE_capillaryTemp,
    IonSource_NONE_capillaryVoltage,
    IonSource_NONE_sourceVoltage,
    IonSource_NONE_sourceVoltageDynamic,
    IonSource_NONE_ionSource,
    IonSource_NONE_temperature,
    IonSource_NONE_coronaDischarge,
    IonSource_NONE_transferLineTemperature,
    IonSource_NONE_gasTemperature,
    IonSource_NONE_voltage,
    IonSource_NONE_usingHelium,
    IonSource_NONE_description,
    IonSource_any
};

class c_ApciSource;
class c_EsiSource;
class c_DartSource;

// From: IonSource.xsd(45)
class c_IonSource
{
    //:snippet:start IonSource
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end IonSource

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_IonSource();
    LMX_GDECL c_IonSource( const c_IonSource & r_rhs );
    LMX_GDECL c_IonSource & operator = ( const c_IonSource & r_rhs );
    LMX_GDECL virtual c_IonSource * clone() const;
    LMX_GDECL void swap( c_IonSource & r_rhs );
    LMX_GDECL virtual ~c_IonSource();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id;
    }

    LMX_GDECL static c_IonSource * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const
    {
        LMX_NO_WARN_UNUSED( p_tracker_in );
        return true;
    }

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "IonSource" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "IonSource" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_1( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_2( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_3( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

// From: IonSource.xsd(46)
class c_ApciSource : public c_IonSource
{
    //:snippet:start ApciSource
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end ApciSource

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_temperature;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_coronaDischarge;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_transferLineTemperature;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ApciSource();
    LMX_GDECL c_ApciSource( const c_ApciSource & r_rhs );
    LMX_GDECL c_ApciSource & operator = ( const c_ApciSource & r_rhs );
    LMX_GDECL virtual c_ApciSource * clone() const;
    LMX_GDECL void swap( c_ApciSource & r_rhs );
    LMX_GDECL virtual ~c_ApciSource();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_IonSource::has_id( id_in );
    }

    // Element(s)

    //    temperature --> xs:double{20<=x<=450} (Default: 20)
    LMX_GDECL const lmx::tlmx_double & get_temperature() const { return m_temperature.get(); }
    LMX_GDECL lmx::elmx_error set_temperature( const lmx::tlmx_double & value );

    //    coronaDischarge --> xs:double{0<=x<=100} (Default: 5)
    LMX_GDECL const lmx::tlmx_double & get_coronaDischarge() const { return m_coronaDischarge.get(); }
    LMX_GDECL lmx::elmx_error set_coronaDischarge( const lmx::tlmx_double & value );

    //    transferLineTemperature --> xs:double[0..1] (Default: 100.0)
    LMX_GDECL const lmx::tlmx_double & get_transferLineTemperature() const { return m_transferLineTemperature.get(); }
    LMX_GDECL lmx::elmx_error set_transferLineTemperature( const lmx::tlmx_double & value ) { return m_transferLineTemperature.set( value ); }
    LMX_GDECL bool isset_transferLineTemperature() const { return m_transferLineTemperature.is_value_set(); }
    LMX_GDECL void unset_transferLineTemperature();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ApciSource" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ApciSource" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_4( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_5( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

// From: IonSource.xsd(71)
class c_EsiSource : public c_IonSource
{
    //:snippet:start EsiSource
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end EsiSource

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_gasTemperature;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_voltage;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_EsiSource();
    LMX_GDECL c_EsiSource( const c_EsiSource & r_rhs );
    LMX_GDECL c_EsiSource & operator = ( const c_EsiSource & r_rhs );
    LMX_GDECL virtual c_EsiSource * clone() const;
    LMX_GDECL void swap( c_EsiSource & r_rhs );
    LMX_GDECL virtual ~c_EsiSource();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_IonSource::has_id( id_in );
    }

    // Element(s)

    //    gasTemperature --> xs:double{20<=x<=400} (Default: 20)
    LMX_GDECL const lmx::tlmx_double & get_gasTemperature() const { return m_gasTemperature.get(); }
    LMX_GDECL lmx::elmx_error set_gasTemperature( const lmx::tlmx_double & value );

    //    voltage --> xs:double{0<=x<=5000} (Default: 3500)
    LMX_GDECL const lmx::tlmx_double & get_voltage() const { return m_voltage.get(); }
    LMX_GDECL lmx::elmx_error set_voltage( const lmx::tlmx_double & value );

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "EsiSource" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "EsiSource" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_6( const bool &, const char * );
#endif // LMX_USER_VALIDATE

// From: IonSource.xsd(95)
class c_DartSource : public c_IonSource
{
    //:snippet:start DartSource
    //:snippet:end DartSource

private:
    // Element(s)
    lmx::ct_simple_pod_single< bool > m_usingHelium;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_DartSource();
    LMX_GDECL c_DartSource( const c_DartSource & r_rhs );
    LMX_GDECL c_DartSource & operator = ( const c_DartSource & r_rhs );
    LMX_GDECL virtual c_DartSource * clone() const;
    LMX_GDECL void swap( c_DartSource & r_rhs );
    LMX_GDECL virtual ~c_DartSource();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_IonSource::has_id( id_in );
    }

    // Element(s)

    //    usingHelium --> xs:boolean (Default: false)
    LMX_GDECL const bool & get_usingHelium() const { return m_usingHelium.get(); }
    LMX_GDECL lmx::elmx_error set_usingHelium( const bool & value ) { return m_usingHelium.set( value ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "DartSource" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "DartSource" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_7( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_8( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_9( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_10( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

// From: IonSource.xsd(3)
class c_ionSourceOptimization
{
    //:snippet:start ionSourceOptimization
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end ionSourceOptimization

private:
    // Attribute(s)
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_version;

    // Element(s)
    lmx::ct_simple_pod_single< bool > m_negative;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_capillaryTemp;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_capillaryVoltage;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_sourceVoltage;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_sourceVoltageDynamic;
    lmx::ct_complex_single< c_IonSource > m_ionSource;
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_description;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ionSourceOptimization();
    LMX_GDECL c_ionSourceOptimization( const c_ionSourceOptimization & r_rhs );
    LMX_GDECL c_ionSourceOptimization & operator = ( const c_ionSourceOptimization & r_rhs );
    LMX_GDECL virtual c_ionSourceOptimization * clone() const;
    LMX_GDECL void swap( c_ionSourceOptimization & r_rhs );
    LMX_GDECL c_ionSourceOptimization( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    // Convenience constructors
    LMX_GDECL c_ionSourceOptimization( const char c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL c_ionSourceOptimization( const wchar_t c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL c_ionSourceOptimization( const char * p_memory, size_t memory_size, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_ionSourceOptimization( const std::string & r_string, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_ionSourceOptimization( const lmx::c_any_info & r_any_info, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL virtual ~c_ionSourceOptimization();

    // Attribute(s)

    //    version --> xs:string[0..1] (Default: 1.2)
    LMX_GDECL const lmx::tlmx_unicode_string & get_version() const { return m_version.get(); }
    LMX_GDECL lmx::elmx_error set_version( const lmx::tlmx_unicode_string & value ) { return m_version.set( value ); }
    LMX_GDECL bool isset_version() const { return m_version.is_value_set(); }
    LMX_GDECL void unset_version();
    // Element(s)

    //    negative --> xs:boolean (Default: false)
    LMX_GDECL const bool & get_negative() const { return m_negative.get(); }
    LMX_GDECL lmx::elmx_error set_negative( const bool & value ) { return m_negative.set( value ); }

    //    capillaryTemp --> xs:double{20<=x<=300} (Default: 20)
    LMX_GDECL const lmx::tlmx_double & get_capillaryTemp() const { return m_capillaryTemp.get(); }
    LMX_GDECL lmx::elmx_error set_capillaryTemp( const lmx::tlmx_double & value );

    //    capillaryVoltage --> xs:double{0<=x<=184} (Default: 0)
    LMX_GDECL const lmx::tlmx_double & get_capillaryVoltage() const { return m_capillaryVoltage.get(); }
    LMX_GDECL lmx::elmx_error set_capillaryVoltage( const lmx::tlmx_double & value );

    //    sourceVoltage --> xs:double{0<=x<=114}[0..1] (Default: 40)
    LMX_GDECL const lmx::tlmx_double & get_sourceVoltage() const { return m_sourceVoltage.get(); }
    LMX_GDECL lmx::elmx_error set_sourceVoltage( const lmx::tlmx_double & value );
    LMX_GDECL bool isset_sourceVoltage() const { return m_sourceVoltage.is_value_set(); }
    LMX_GDECL void unset_sourceVoltage();

    //    sourceVoltageDynamic --> xs:double{0<=x<=114}[0..1] (Default: 0)
    LMX_GDECL const lmx::tlmx_double & get_sourceVoltageDynamic() const { return m_sourceVoltageDynamic.get(); }
    LMX_GDECL lmx::elmx_error set_sourceVoltageDynamic( const lmx::tlmx_double & value );
    LMX_GDECL bool isset_sourceVoltageDynamic() const { return m_sourceVoltageDynamic.is_value_set(); }
    LMX_GDECL void unset_sourceVoltageDynamic();

    //    ionSource --> IonSource
    LMX_GDECL const c_IonSource & get_ionSource() const { return m_ionSource.get(); }
    LMX_GDECL c_IonSource & get_ionSource() { return m_ionSource.get(); } // For read/write access
    LMX_GDECL c_IonSource & assign_ionSource( const c_IonSource & value ) { return (get_ionSource() = value); }
    LMX_GDECL c_IonSource & assign_ionSource( c_IonSource * p ) { return m_ionSource.assign( p ); }

    //    description --> xs:string[0..1] (Default: )
    LMX_GDECL const lmx::tlmx_unicode_string & get_description() const { return m_description.get(); }
    LMX_GDECL lmx::elmx_error set_description( const lmx::tlmx_unicode_string & value ) { return m_description.set( value ); }
    LMX_GDECL bool isset_description() const { return m_description.is_value_set(); }
    LMX_GDECL void unset_description();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ionSourceOptimization" ) const;

    LMX_GDECL static const lmx::s_ns_map * ns_map() { return IonSource_reader; }
    // Convenience marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #if defined( _MSC_VER ) && _MSC_VER >= 1400
        LMX_GDECL lmx::elmx_error marshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #endif
    LMX_GDECL lmx::elmx_error marshal( std::string * p_string, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error marshal( std::ostream & r_sos, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error unmarshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL lmx::elmx_error unmarshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL lmx::elmx_error unmarshal( const char * p_memory, size_t memory_size, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL lmx::elmx_error unmarshal( const std::string & r_string, lmx::s_debug_error * p_debug_error = LMXNULL )
    {
        return unmarshal( r_string.data(), r_string.size(), p_debug_error );
    }
    LMX_GDECL lmx::elmx_error unmarshal( const lmx::c_any_info & r_any_info, lmx::s_debug_error * p_debug_error = LMXNULL );

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ionSourceOptimization" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader );
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

}   // end of namespace AdvionObjects

#if defined( _MSC_VER ) && _MSC_VER >= 1400
#pragma warning (pop)  // Restore disabled warnings
#endif


#endif      // End of include guard
