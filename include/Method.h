//
//                  W A R N I N G:  DO NOT MANUALLY MODIFY THIS FILE
//                  ------------------------------------------------
//
// This file has been automatically generated by Codalogic's LMX W3C Schema to 
// C++ compiler.  
//
// It should not be manually modified as this may cause the code to break, or 
// operate in unexpected ways.
// 
// To change the contents of this file, modify the schema, and then re-compile.

//                 Copyright (c) 2019 Codalogic Ltd.
//
// See the LMX license agreement for restrictions on the use of this file.

// THIS FILE AND THE SOFTWARE CONTAINED HEREIN IS PROVIDED "AS IS", WITHOUT
// WARRANTY OF ANY KIND.
//
// CODALOGIC LTD SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY ANYONE
// OR ANYTHING DUE TO THE USE OF THIS FILE HOWEVER THEY MAY BE CAUSED.
//
// For more information on the LMX compiler, go to:
// 
//     http://www.xml2cpp.com
//
// Also see:
//
//     http://www.codalogic.com
//

// TargetNamepsace: 
// Source File: Method.xsd
// LMX Version: 7.2
// Compile options: -autover2 -local-enums -ns-map-base Method_ -prefix-enum Method_ -no-ev -no-gen-date -no-html -no-root-class -include-h AdvionObjects.h -snippets -output-defaults -cns AdvionObjects Method.xsd ..\\..\\cpp\\AdvionObjects\\Method

// License details (This file is not valid without this information)
//     License number: 1322669991
//     License owning company: Advion, Inc
//     License owning e-mail addr: trumborb@advion.com
//     License authorising code: 84a013fdcf68a3d1d4aa36b28356d7f7
//
//       Copyright (c) 2019 Advion, Inc.

#ifndef __ADVIONOBJECTS_METHOD_H__
#define __ADVIONOBJECTS_METHOD_H__

#if defined( _MSC_VER ) && _MSC_VER >= 1400
#pragma warning (push)
#pragma warning (disable:4100)  // Disable unreferenced formal parameter
#endif

#include "AdvionObjects.h"

#include "lmxuser.h"

// To help MS intellisense
#ifndef LMX_GDECL
#define LMX_GDECL
#endif

namespace AdvionObjects {

LMX_GDECL extern const lmx::s_ns_map Method_reader[];
LMX_GDECL extern const lmx::s_ns_map Method_writer_1[];
LMX_GDECL extern const lmx::s_ns_map Method_writer_2[];
LMX_GDECL extern const lmx::s_ns_map Method_writer_3[];
LMX_GDECL extern const lmx::s_ns_map Method_writer_4[];
LMX_GDECL extern const lmx::s_ns_map Method_writer_5[];
LMX_GDECL extern const lmx::s_ns_map Method_writer_6[];

enum
{
    Method_error = lmx::EXE_LAST_XML_EVENT,
    Method_NONE_method,
    Method_NONE_version,
    Method_NONE_description,
    Method_NONE_runTime,
    Method_NONE_scanMode,
    Method_NONE_start,
    Method_NONE_end,
    Method_NONE_scanTime,
    Method_NONE_scanDelay,
    Method_NONE_deltaBackgroundParameters,
    Method_NONE_startTime,
    Method_NONE_endTime,
    Method_NONE_threshold,
    Method_NONE_minWidth,
    Method_NONE_noiseOffset,
    Method_NONE_useTwoIonSourceOptimizations,
    Method_NONE_massOfInterest,
    Method_NONE_mass,
    Method_NONE_span,
    Method_NONE_dwellTime,
    Method_NONE_stopTime,
    Method_NONE_sourceVoltageOffset,
    Method_NONE_smoothing,
    Method_NONE_radius,
    Method_NONE_iterations,
    Method_NONE_removeNoise,
    Method_NONE_analogOutputs,
    Method_NONE_output,
    Method_NONE_enabled,
    Method_NONE_maxIntensity,
    Method_NONE_maxVoltage,
    Method_NONE_baselineRemoval,
    Method_NONE_time,
    Method_NONE_source,
    Method_NONE_scanModeIndex,
    Method_NONE_startMass,
    Method_NONE_endMass,
    Method_NONE_simIndex,
    Method_NONE_analogInputs,
    Method_NONE_input,
    Method_NONE_name,
    Method_NONE_contactClosureIn,
    Method_NONE_line,
    Method_NONE_onLowToHigh,
    Method_NONE_delayMS,
    Method_NONE_stop,
    Method_NONE_contactClosuresOut,
    Method_NONE_contactClosure,
    Method_NONE_closeTrigger,
    Method_NONE_seconds,
    Method_NONE_delaySeconds,
    Method_NONE_closeTimeSeconds,
    Method_NONE_openTimeSeconds,
    Method_NONE_aboveThreshold,
    Method_NONE_timePastThreshold,
    Method_NONE_aboveGradient,
    Method_NONE_useGradient,
    Method_NONE_gradient,
    Method_NONE_delay,
    Method_NONE_openTrigger,
    Method_NONE_additionalInfo,
    Method_NONE_value,
    Method_NONE_quantitation,
    Method_NONE_calibrationPath,
    Method_NONE_qcOnly,
    Method_NONE_isotopeRatio,
    Method_NONE_isotopeDilution,
    Method_NONE_standardAddition,
    Method_NONE_backgroundSubtraction,
    Method_NONE_analyte,
    Method_NONE_id,
    Method_NONE_massSpan,
    Method_NONE_additionalMasses,
    Method_NONE_retentionTime,
    Method_NONE_retentionTimeSpan,
    Method_NONE_concentrationUnits,
    Method_NONE_intensityMetric,
    Method_NONE_settings,
    Method_NONE_scanModeId,
    Method_NONE_referenceAnalyteId,
    Method_NONE_internalStandardId,
    Method_NONE_sampleListFileIndex,
    Method_NONE_fitType,
    Method_NONE_weighting,
    Method_NONE_peakDetection,
    Method_NONE_maxWidth,
    Method_NONE_excludeNoise,
    Method_NONE_sigma,
    Method_NONE_numPeakLabels,
    Method_NONE_estimateWidth,
    Method_NONE_integrationPoint,
    Method_NONE_startRetentionTime,
    Method_NONE_height,
    Method_NONE_manualHeight,
    Method_NONE_targetRetentionTime,
    Method_NONE_userModified,
    Method_NONE_filter,
    Method_NONE_width,
    Method_NONE_internalStandard,
    Method_NONE_calibrationStandard,
    Method_NONE_type,
    Method_NONE_calibrationAnalyte,
    Method_NONE_analyteId,
    Method_NONE_concentration,
    Method_NONE_semiQuantSettings,
    Method_NONE_useDefaultStandards,
    Method_NONE_defaultStandard,
    Method_NONE_isotope,
    Method_NONE_atomicNumber,
    Method_NONE_massNumber,
    Method_NONE_relativeAtomicMass,
    Method_NONE_intensity,
    Method_NONE_instrumentType,
    Method_NONE_scanModeType,
    Method_NONE_setup,
    Method_NONE_processMethod,
    Method_NONE_backgroundOptions,
    Method_NONE_enableMultiple,
    Method_NONE_removeFromSpectra,
    Method_NONE_removeFromChromatograms,
    Method_NONE_backgroundSpectra,
    Method_NONE_parentSpectrumInfo,
    Method_NONE_isStick,
    Method_NONE_endRetentionTime,
    Method_NONE_isFullRetentionTime,
    Method_NONE_isStacked,
    Method_NONE_startX,
    Method_NONE_endX,
    Method_NONE_backgroundSpectrum,
    Method_NONE_currentFilter,
    Method_NONE_appliedFilters,
    Method_NONE_peakDetections,
    Method_NONE_delta,
    Method_NONE_index,
    Method_NONE_spectrumInfos,
    Method_NONE_parentChromInfo,
    Method_NONE_chromInfos,
    Method_any
};

class c_RangeScanMode;
class c_SIMScanMode;

// From: Method.xsd(39)
class c_ScanMode
{
    //:snippet:start ScanMode
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end ScanMode

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ScanMode();
    LMX_GDECL c_ScanMode( const c_ScanMode & r_rhs );
    LMX_GDECL c_ScanMode & operator = ( const c_ScanMode & r_rhs );
    LMX_GDECL virtual c_ScanMode * clone() const;
    LMX_GDECL void swap( c_ScanMode & r_rhs );
    LMX_GDECL virtual ~c_ScanMode();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id;
    }

    LMX_GDECL static c_ScanMode * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const
    {
        LMX_NO_WARN_UNUSED( p_tracker_in );
        return true;
    }

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ScanMode" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ScanMode" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_1( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_2( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_3( const lmx::tlmx_uns32 &, const char * );
#endif // LMX_USER_VALIDATE

// From: Method.xsd(85)
class c_DeltaBackgroundParameters
{
    //:snippet:start DeltaBackgroundParameters
    //:snippet:end DeltaBackgroundParameters

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_startTime;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_endTime;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_threshold;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_minWidth;
    lmx::ct_simple_pod_single< lmx::tlmx_uns32 > m_noiseOffset;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_DeltaBackgroundParameters();
    LMX_GDECL c_DeltaBackgroundParameters( const c_DeltaBackgroundParameters & r_rhs );
    LMX_GDECL c_DeltaBackgroundParameters & operator = ( const c_DeltaBackgroundParameters & r_rhs );
    LMX_GDECL virtual c_DeltaBackgroundParameters * clone() const;
    LMX_GDECL void swap( c_DeltaBackgroundParameters & r_rhs );
    LMX_GDECL virtual ~c_DeltaBackgroundParameters();

    // Element(s)

    //    startTime --> xs:double{0.0<=x} (Default: 0.0)
    LMX_GDECL const lmx::tlmx_double & get_startTime() const { return m_startTime.get(); }
    LMX_GDECL lmx::elmx_error set_startTime( const lmx::tlmx_double & value );

    //    endTime --> xs:double{0.0<=x} (Default: 10.0)
    LMX_GDECL const lmx::tlmx_double & get_endTime() const { return m_endTime.get(); }
    LMX_GDECL lmx::elmx_error set_endTime( const lmx::tlmx_double & value );

    //    threshold --> xs:double{0.0<=x} (Default: 3.0)
    LMX_GDECL const lmx::tlmx_double & get_threshold() const { return m_threshold.get(); }
    LMX_GDECL lmx::elmx_error set_threshold( const lmx::tlmx_double & value );

    //    minWidth --> xs:double{0.05<=x} (Default: 0.4)
    LMX_GDECL const lmx::tlmx_double & get_minWidth() const { return m_minWidth.get(); }
    LMX_GDECL lmx::elmx_error set_minWidth( const lmx::tlmx_double & value );

    //    noiseOffset --> xs:int{1<=x<=2147483647} (Default: 1000000)
    LMX_GDECL const lmx::tlmx_uns32 & get_noiseOffset() const { return m_noiseOffset.get(); }
    LMX_GDECL lmx::elmx_error set_noiseOffset( const lmx::tlmx_uns32 & value );

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "DeltaBackgroundParameters" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "DeltaBackgroundParameters" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_4( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_5( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_6( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_7( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_8( const lmx::tlmx_uns32 &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_9( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

// From: Method.xsd(133)
class c_MassOfInterest
{
    //:snippet:start MassOfInterest
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end MassOfInterest

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_mass;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_span;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_dwellTime;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_scanDelay;
    lmx::ct_simple_pod_optional< lmx::tlmx_uns32 > m_startTime;
    lmx::ct_simple_pod_optional< lmx::tlmx_uns32 > m_stopTime;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_sourceVoltageOffset;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_MassOfInterest();
    LMX_GDECL c_MassOfInterest( const c_MassOfInterest & r_rhs );
    LMX_GDECL c_MassOfInterest & operator = ( const c_MassOfInterest & r_rhs );
    LMX_GDECL virtual c_MassOfInterest * clone() const;
    LMX_GDECL void swap( c_MassOfInterest & r_rhs );
    LMX_GDECL virtual ~c_MassOfInterest();

    // Element(s)

    //    mass --> xs:double{10<=x<=2000} (Default: 200)
    LMX_GDECL const lmx::tlmx_double & get_mass() const { return m_mass.get(); }
    LMX_GDECL lmx::elmx_error set_mass( const lmx::tlmx_double & value );

    //    span --> xs:double{0<=x<=2000} (Default: 0.3)
    LMX_GDECL const lmx::tlmx_double & get_span() const { return m_span.get(); }
    LMX_GDECL lmx::elmx_error set_span( const lmx::tlmx_double & value );

    //    dwellTime --> xs:double{10<=x<=1000} (Default: 50)
    LMX_GDECL const lmx::tlmx_double & get_dwellTime() const { return m_dwellTime.get(); }
    LMX_GDECL lmx::elmx_error set_dwellTime( const lmx::tlmx_double & value );

    //    scanDelay --> xs:double{0<=x} (Default: 10)
    LMX_GDECL const lmx::tlmx_double & get_scanDelay() const { return m_scanDelay.get(); }
    LMX_GDECL lmx::elmx_error set_scanDelay( const lmx::tlmx_double & value );

    //    startTime --> xs:int{0<=x<=2147483647}[0..1] (Default: 0)
    LMX_GDECL const lmx::tlmx_uns32 & get_startTime() const { return m_startTime.get(); }
    LMX_GDECL lmx::elmx_error set_startTime( const lmx::tlmx_uns32 & value );
    LMX_GDECL bool isset_startTime() const { return m_startTime.is_value_set(); }
    LMX_GDECL void unset_startTime();

    //    stopTime --> xs:int{0<=x<=2147483647}[0..1] (Default: 1000000)
    LMX_GDECL const lmx::tlmx_uns32 & get_stopTime() const { return m_stopTime.get(); }
    LMX_GDECL lmx::elmx_error set_stopTime( const lmx::tlmx_uns32 & value );
    LMX_GDECL bool isset_stopTime() const { return m_stopTime.is_value_set(); }
    LMX_GDECL void unset_stopTime();

    //    sourceVoltageOffset --> xs:double{0<=x<=114}[0..1]
    LMX_GDECL const lmx::tlmx_double & get_sourceVoltageOffset() const { return m_sourceVoltageOffset.get(); }
    LMX_GDECL lmx::elmx_error set_sourceVoltageOffset( const lmx::tlmx_double & value );
    LMX_GDECL bool isset_sourceVoltageOffset() const { return m_sourceVoltageOffset.is_value_set(); }
    LMX_GDECL void unset_sourceVoltageOffset() { m_sourceVoltageOffset.unset(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "MassOfInterest" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "MassOfInterest" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_10( const lmx::tlmx_uns8 &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_11( const lmx::tlmx_uns8 &, const char * );
#endif // LMX_USER_VALIDATE

// From: Method.xsd(190)
class c_Smoothing
{
    //:snippet:start Smoothing
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end Smoothing

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_uns8 > m_radius;
    lmx::ct_simple_pod_single< lmx::tlmx_uns8 > m_iterations;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_Smoothing();
    LMX_GDECL c_Smoothing( const c_Smoothing & r_rhs );
    LMX_GDECL c_Smoothing & operator = ( const c_Smoothing & r_rhs );
    LMX_GDECL virtual c_Smoothing * clone() const;
    LMX_GDECL void swap( c_Smoothing & r_rhs );
    LMX_GDECL virtual ~c_Smoothing();

    // Element(s)

    //    radius --> xs:int{2<=x<=12} (Default: 7)
    LMX_GDECL const lmx::tlmx_uns8 & get_radius() const { return m_radius.get(); }
    LMX_GDECL lmx::elmx_error set_radius( const lmx::tlmx_uns8 & value );

    //    iterations --> xs:int{0<=x<=5} (Default: 0)
    LMX_GDECL const lmx::tlmx_uns8 & get_iterations() const { return m_iterations.get(); }
    LMX_GDECL lmx::elmx_error set_iterations( const lmx::tlmx_uns8 & value );

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "Smoothing" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "Smoothing" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_12( const bool &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_13( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_14( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_15( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

// From: Method.xsd(318)
class c_AnalogInput
{
    //:snippet:start AnalogInput
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end AnalogInput

private:
    // Element(s)
    lmx::ct_simple_pod_single< bool > m_enabled;
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_name;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_maxIntensity;
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_maxVoltage;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_AnalogInput();
    LMX_GDECL c_AnalogInput( const c_AnalogInput & r_rhs );
    LMX_GDECL c_AnalogInput & operator = ( const c_AnalogInput & r_rhs );
    LMX_GDECL virtual c_AnalogInput * clone() const;
    LMX_GDECL void swap( c_AnalogInput & r_rhs );
    LMX_GDECL virtual ~c_AnalogInput();

    // Element(s)

    //    enabled --> xs:boolean (Default: false)
    LMX_GDECL const bool & get_enabled() const { return m_enabled.get(); }
    LMX_GDECL lmx::elmx_error set_enabled( const bool & value ) { return m_enabled.set( value ); }

    //    name --> xs:string
    LMX_GDECL const lmx::tlmx_unicode_string & get_name() const { return m_name.get(); }
    LMX_GDECL lmx::elmx_error set_name( const lmx::tlmx_unicode_string & value ) { return m_name.set( value ); }

    //    maxIntensity --> xs:double (Default: 1000000000.0)
    LMX_GDECL const lmx::tlmx_double & get_maxIntensity() const { return m_maxIntensity.get(); }
    LMX_GDECL lmx::elmx_error set_maxIntensity( const lmx::tlmx_double & value ) { return m_maxIntensity.set( value ); }

    //    maxVoltage --> xs:string (Default: 1v)
    LMX_GDECL const lmx::tlmx_unicode_string & get_maxVoltage() const { return m_maxVoltage.get(); }
    LMX_GDECL lmx::elmx_error set_maxVoltage( const lmx::tlmx_unicode_string & value );
    enum Method_enum_maxVoltage {
            Method_maxVoltage_unknown,
            Method_maxVoltage__100mv,
            Method_maxVoltage__1v,
            Method_maxVoltage__10v };
    LMX_GDECL Method_enum_maxVoltage getenum_maxVoltage() const;
    LMX_GDECL bool setenum_maxVoltage( Method_enum_maxVoltage value );
            // Enum options:
            // AdvionObjects::c_AnalogInput::Method_maxVoltage__100mv
            // AdvionObjects::c_AnalogInput::Method_maxVoltage__1v
            // AdvionObjects::c_AnalogInput::Method_maxVoltage__10v

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "AnalogInput" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "AnalogInput" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

class c_RepeatTimeTrigger;
class c_TimeTrigger;
class c_TICPeakTrigger;
class c_DeltaXICPeakTrigger;
class c_DeltaICPeakTrigger;
class c_XICPeakTrigger;
class c_SIMPeakTrigger;

// From: Method.xsd(353)
class c_ClosureOutTrigger
{
    //:snippet:start ClosureOutTrigger
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end ClosureOutTrigger

private:
    // Element(s)
    lmx::ct_simple_pod_single< bool > m_enabled;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ClosureOutTrigger();
    LMX_GDECL c_ClosureOutTrigger( const c_ClosureOutTrigger & r_rhs );
    LMX_GDECL c_ClosureOutTrigger & operator = ( const c_ClosureOutTrigger & r_rhs );
    LMX_GDECL virtual c_ClosureOutTrigger * clone() const;
    LMX_GDECL void swap( c_ClosureOutTrigger & r_rhs );
    LMX_GDECL virtual ~c_ClosureOutTrigger();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id;
    }

    LMX_GDECL static c_ClosureOutTrigger * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    //    enabled --> xs:boolean (Default: false)
    LMX_GDECL const bool & get_enabled() const { return m_enabled.get(); }
    LMX_GDECL lmx::elmx_error set_enabled( const bool & value ) { return m_enabled.set( value ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ClosureOutTrigger" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ClosureOutTrigger" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_16( const lmx::tlmx_int32 &, const char * );
#endif // LMX_USER_VALIDATE

// From: Method.xsd(358)
class c_TimeTrigger : public c_ClosureOutTrigger
{
    //:snippet:start TimeTrigger
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end TimeTrigger

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_int32 > m_seconds;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_TimeTrigger();
    LMX_GDECL c_TimeTrigger( const c_TimeTrigger & r_rhs );
    LMX_GDECL c_TimeTrigger & operator = ( const c_TimeTrigger & r_rhs );
    LMX_GDECL virtual c_TimeTrigger * clone() const;
    LMX_GDECL void swap( c_TimeTrigger & r_rhs );
    LMX_GDECL virtual ~c_TimeTrigger();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ClosureOutTrigger::has_id( id_in );
    }

    // Element(s)

    //    seconds --> xs:int{-2147483648<=x<=2147483647} (Default: 100)
    LMX_GDECL const lmx::tlmx_int32 & get_seconds() const { return m_seconds.get(); }
    LMX_GDECL lmx::elmx_error set_seconds( const lmx::tlmx_int32 & value );

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "TimeTrigger" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "TimeTrigger" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(367)
class c_RepeatTimeTrigger : public c_ClosureOutTrigger
{
    //:snippet:start RepeatTimeTrigger
    //:snippet:end RepeatTimeTrigger

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_int32 > m_delaySeconds;
    lmx::ct_simple_pod_single< lmx::tlmx_int32 > m_closeTimeSeconds;
    lmx::ct_simple_pod_single< lmx::tlmx_int32 > m_openTimeSeconds;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_RepeatTimeTrigger();
    LMX_GDECL c_RepeatTimeTrigger( const c_RepeatTimeTrigger & r_rhs );
    LMX_GDECL c_RepeatTimeTrigger & operator = ( const c_RepeatTimeTrigger & r_rhs );
    LMX_GDECL virtual c_RepeatTimeTrigger * clone() const;
    LMX_GDECL void swap( c_RepeatTimeTrigger & r_rhs );
    LMX_GDECL virtual ~c_RepeatTimeTrigger();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ClosureOutTrigger::has_id( id_in );
    }

    // Element(s)

    //    delaySeconds --> xs:int{-2147483648<=x<=2147483647} (Default: 100)
    LMX_GDECL const lmx::tlmx_int32 & get_delaySeconds() const { return m_delaySeconds.get(); }
    LMX_GDECL lmx::elmx_error set_delaySeconds( const lmx::tlmx_int32 & value );

    //    closeTimeSeconds --> xs:int{-2147483648<=x<=2147483647} (Default: 100)
    LMX_GDECL const lmx::tlmx_int32 & get_closeTimeSeconds() const { return m_closeTimeSeconds.get(); }
    LMX_GDECL lmx::elmx_error set_closeTimeSeconds( const lmx::tlmx_int32 & value );

    //    openTimeSeconds --> xs:int{-2147483648<=x<=2147483647} (Default: 100)
    LMX_GDECL const lmx::tlmx_int32 & get_openTimeSeconds() const { return m_openTimeSeconds.get(); }
    LMX_GDECL lmx::elmx_error set_openTimeSeconds( const lmx::tlmx_int32 & value );

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "RepeatTimeTrigger" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "RepeatTimeTrigger" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

class c_TICPeakTrigger;
class c_DeltaXICPeakTrigger;
class c_DeltaICPeakTrigger;
class c_XICPeakTrigger;
class c_SIMPeakTrigger;

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_17( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

// From: Method.xsd(378)
class c_PeakTrigger : public c_ClosureOutTrigger
{
    //:snippet:start PeakTrigger
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end PeakTrigger

private:
    // Element(s)
    lmx::ct_simple_pod_single< bool > m_aboveThreshold;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_threshold;
    lmx::ct_simple_pod_single< lmx::tlmx_uns32 > m_timePastThreshold;
    lmx::ct_simple_pod_single< bool > m_aboveGradient;
    lmx::ct_simple_pod_single< bool > m_useGradient;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_gradient;
    lmx::ct_simple_pod_single< lmx::tlmx_uns32 > m_delay;
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_source;
    lmx::ct_simple_pod_optional< lmx::tlmx_uns32 > m_scanModeIndex;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_PeakTrigger();
    LMX_GDECL c_PeakTrigger( const c_PeakTrigger & r_rhs );
    LMX_GDECL c_PeakTrigger & operator = ( const c_PeakTrigger & r_rhs );
    LMX_GDECL virtual c_PeakTrigger * clone() const;
    LMX_GDECL void swap( c_PeakTrigger & r_rhs );
    LMX_GDECL virtual ~c_PeakTrigger();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ClosureOutTrigger::has_id( id_in );
    }

    LMX_GDECL static c_PeakTrigger * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    //    aboveThreshold --> xs:boolean (Default: true)
    LMX_GDECL const bool & get_aboveThreshold() const { return m_aboveThreshold.get(); }
    LMX_GDECL lmx::elmx_error set_aboveThreshold( const bool & value ) { return m_aboveThreshold.set( value ); }

    //    threshold --> xs:double{0<=x} (Default: 10000)
    LMX_GDECL const lmx::tlmx_double & get_threshold() const { return m_threshold.get(); }
    LMX_GDECL lmx::elmx_error set_threshold( const lmx::tlmx_double & value );

    //    timePastThreshold --> xs:int{0<=x<=2147483647} (Default: 0)
    LMX_GDECL const lmx::tlmx_uns32 & get_timePastThreshold() const { return m_timePastThreshold.get(); }
    LMX_GDECL lmx::elmx_error set_timePastThreshold( const lmx::tlmx_uns32 & value );

    //    aboveGradient --> xs:boolean (Default: true)
    LMX_GDECL const bool & get_aboveGradient() const { return m_aboveGradient.get(); }
    LMX_GDECL lmx::elmx_error set_aboveGradient( const bool & value ) { return m_aboveGradient.set( value ); }

    //    useGradient --> xs:boolean (Default: false)
    LMX_GDECL const bool & get_useGradient() const { return m_useGradient.get(); }
    LMX_GDECL lmx::elmx_error set_useGradient( const bool & value ) { return m_useGradient.set( value ); }

    //    gradient --> xs:double (Default: 0.0)
    LMX_GDECL const lmx::tlmx_double & get_gradient() const { return m_gradient.get(); }
    LMX_GDECL lmx::elmx_error set_gradient( const lmx::tlmx_double & value ) { return m_gradient.set( value ); }

    //    delay --> xs:int{0<=x<=2147483647} (Default: 0)
    LMX_GDECL const lmx::tlmx_uns32 & get_delay() const { return m_delay.get(); }
    LMX_GDECL lmx::elmx_error set_delay( const lmx::tlmx_uns32 & value );

    //    source --> xs:string[0..1] (Default: First)
    LMX_GDECL const lmx::tlmx_unicode_string & get_source() const { return m_source.get(); }
    LMX_GDECL lmx::elmx_error set_source( const lmx::tlmx_unicode_string & value );
    enum Method_enum_source {
            Method_source_unknown,
            Method_source__First,
            Method_source__Second };
    LMX_GDECL Method_enum_source getenum_source() const;
    LMX_GDECL bool setenum_source( Method_enum_source value );
            // Enum options:
            // AdvionObjects::c_PeakTrigger::Method_source__First
            // AdvionObjects::c_PeakTrigger::Method_source__Second
    LMX_GDECL bool isset_source() const { return m_source.is_value_set(); }
    LMX_GDECL void unset_source();

    //    scanModeIndex --> xs:int{0<=x<=2147483647}[0..1] (Default: 0)
    LMX_GDECL const lmx::tlmx_uns32 & get_scanModeIndex() const { return m_scanModeIndex.get(); }
    LMX_GDECL lmx::elmx_error set_scanModeIndex( const lmx::tlmx_uns32 & value );
    LMX_GDECL bool isset_scanModeIndex() const { return m_scanModeIndex.is_value_set(); }
    LMX_GDECL void unset_scanModeIndex();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "PeakTrigger" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "PeakTrigger" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(419)
class c_TICPeakTrigger : public c_PeakTrigger
{
    //:snippet:start TICPeakTrigger
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end TICPeakTrigger

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_TICPeakTrigger();
    LMX_GDECL c_TICPeakTrigger( const c_TICPeakTrigger & r_rhs );
    LMX_GDECL c_TICPeakTrigger & operator = ( const c_TICPeakTrigger & r_rhs );
    LMX_GDECL virtual c_TICPeakTrigger * clone() const;
    LMX_GDECL void swap( c_TICPeakTrigger & r_rhs );
    LMX_GDECL virtual ~c_TICPeakTrigger();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_PeakTrigger::has_id( id_in );
    }

    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "TICPeakTrigger" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "TICPeakTrigger" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

class c_DeltaXICPeakTrigger;
class c_XICPeakTrigger;

// From: Method.xsd(424)
class c_ExtractedPeakTrigger : public c_PeakTrigger
{
    //:snippet:start ExtractedPeakTrigger
    //:snippet:end ExtractedPeakTrigger

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_startMass;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_endMass;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ExtractedPeakTrigger();
    LMX_GDECL c_ExtractedPeakTrigger( const c_ExtractedPeakTrigger & r_rhs );
    LMX_GDECL c_ExtractedPeakTrigger & operator = ( const c_ExtractedPeakTrigger & r_rhs );
    LMX_GDECL virtual c_ExtractedPeakTrigger * clone() const;
    LMX_GDECL void swap( c_ExtractedPeakTrigger & r_rhs );
    LMX_GDECL virtual ~c_ExtractedPeakTrigger();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_PeakTrigger::has_id( id_in );
    }

    LMX_GDECL static c_ExtractedPeakTrigger * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    //    startMass --> xs:double (Default: 499.5)
    LMX_GDECL const lmx::tlmx_double & get_startMass() const { return m_startMass.get(); }
    LMX_GDECL lmx::elmx_error set_startMass( const lmx::tlmx_double & value ) { return m_startMass.set( value ); }

    //    endMass --> xs:double (Default: 500.5)
    LMX_GDECL const lmx::tlmx_double & get_endMass() const { return m_endMass.get(); }
    LMX_GDECL lmx::elmx_error set_endMass( const lmx::tlmx_double & value ) { return m_endMass.set( value ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ExtractedPeakTrigger" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ExtractedPeakTrigger" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(434)
class c_XICPeakTrigger : public c_ExtractedPeakTrigger
{
    //:snippet:start XICPeakTrigger
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end XICPeakTrigger

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_XICPeakTrigger();
    LMX_GDECL c_XICPeakTrigger( const c_XICPeakTrigger & r_rhs );
    LMX_GDECL c_XICPeakTrigger & operator = ( const c_XICPeakTrigger & r_rhs );
    LMX_GDECL virtual c_XICPeakTrigger * clone() const;
    LMX_GDECL void swap( c_XICPeakTrigger & r_rhs );
    LMX_GDECL virtual ~c_XICPeakTrigger();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ExtractedPeakTrigger::has_id( id_in );
    }

    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "XICPeakTrigger" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "XICPeakTrigger" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(439)
class c_SIMPeakTrigger : public c_PeakTrigger
{
    //:snippet:start SIMPeakTrigger
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end SIMPeakTrigger

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_uns32 > m_simIndex;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_SIMPeakTrigger();
    LMX_GDECL c_SIMPeakTrigger( const c_SIMPeakTrigger & r_rhs );
    LMX_GDECL c_SIMPeakTrigger & operator = ( const c_SIMPeakTrigger & r_rhs );
    LMX_GDECL virtual c_SIMPeakTrigger * clone() const;
    LMX_GDECL void swap( c_SIMPeakTrigger & r_rhs );
    LMX_GDECL virtual ~c_SIMPeakTrigger();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_PeakTrigger::has_id( id_in );
    }

    // Element(s)

    //    simIndex --> xs:int{0<=x<=2147483647} (Default: 0)
    LMX_GDECL const lmx::tlmx_uns32 & get_simIndex() const { return m_simIndex.get(); }
    LMX_GDECL lmx::elmx_error set_simIndex( const lmx::tlmx_uns32 & value );

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "SIMPeakTrigger" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "SIMPeakTrigger" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(454)
class c_DeltaICPeakTrigger : public c_PeakTrigger
{
    //:snippet:start DeltaICPeakTrigger
    //:snippet:end DeltaICPeakTrigger

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_DeltaICPeakTrigger();
    LMX_GDECL c_DeltaICPeakTrigger( const c_DeltaICPeakTrigger & r_rhs );
    LMX_GDECL c_DeltaICPeakTrigger & operator = ( const c_DeltaICPeakTrigger & r_rhs );
    LMX_GDECL virtual c_DeltaICPeakTrigger * clone() const;
    LMX_GDECL void swap( c_DeltaICPeakTrigger & r_rhs );
    LMX_GDECL virtual ~c_DeltaICPeakTrigger();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_PeakTrigger::has_id( id_in );
    }

    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "DeltaICPeakTrigger" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "DeltaICPeakTrigger" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(459)
class c_DeltaXICPeakTrigger : public c_ExtractedPeakTrigger
{
    //:snippet:start DeltaXICPeakTrigger
    //:snippet:end DeltaXICPeakTrigger

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_DeltaXICPeakTrigger();
    LMX_GDECL c_DeltaXICPeakTrigger( const c_DeltaXICPeakTrigger & r_rhs );
    LMX_GDECL c_DeltaXICPeakTrigger & operator = ( const c_DeltaXICPeakTrigger & r_rhs );
    LMX_GDECL virtual c_DeltaXICPeakTrigger * clone() const;
    LMX_GDECL void swap( c_DeltaXICPeakTrigger & r_rhs );
    LMX_GDECL virtual ~c_DeltaXICPeakTrigger();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ExtractedPeakTrigger::has_id( id_in );
    }

    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "DeltaXICPeakTrigger" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "DeltaXICPeakTrigger" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(470)
class c_AdditionalInfo
{
    //:snippet:start AdditionalInfo
    //:snippet:end AdditionalInfo

private:
    // Element(s)
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_name;
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_value;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_AdditionalInfo();
    LMX_GDECL c_AdditionalInfo( const c_AdditionalInfo & r_rhs );
    LMX_GDECL c_AdditionalInfo & operator = ( const c_AdditionalInfo & r_rhs );
    LMX_GDECL virtual c_AdditionalInfo * clone() const;
    LMX_GDECL void swap( c_AdditionalInfo & r_rhs );
    LMX_GDECL virtual ~c_AdditionalInfo();

    // Element(s)

    //    name --> xs:string
    LMX_GDECL const lmx::tlmx_unicode_string & get_name() const { return m_name.get(); }
    LMX_GDECL lmx::elmx_error set_name( const lmx::tlmx_unicode_string & value ) { return m_name.set( value ); }

    //    value --> xs:string
    LMX_GDECL const lmx::tlmx_unicode_string & get_value() const { return m_value.get(); }
    LMX_GDECL lmx::elmx_error set_value( const lmx::tlmx_unicode_string & value ) { return m_value.set( value ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "AdditionalInfo" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "AdditionalInfo" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_18( const lmx::tlmx_uns8 &, const char * );
#endif // LMX_USER_VALIDATE

// From: MethodCommon.xsd(9)
class c_ClosureTriggerIn
{
    //:snippet:start ClosureTriggerIn
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end ClosureTriggerIn

private:
    // Element(s)
    lmx::ct_simple_pod_single< bool > m_enabled;
    lmx::ct_simple_pod_single< lmx::tlmx_uns8 > m_line;
    lmx::ct_simple_pod_single< bool > m_onLowToHigh;
    lmx::ct_simple_pod_single< lmx::tlmx_uns32 > m_delayMS;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ClosureTriggerIn();
    LMX_GDECL c_ClosureTriggerIn( const c_ClosureTriggerIn & r_rhs );
    LMX_GDECL c_ClosureTriggerIn & operator = ( const c_ClosureTriggerIn & r_rhs );
    LMX_GDECL virtual c_ClosureTriggerIn * clone() const;
    LMX_GDECL void swap( c_ClosureTriggerIn & r_rhs );
    LMX_GDECL virtual ~c_ClosureTriggerIn();

    // Element(s)

    //    enabled --> xs:boolean (Default: false)
    LMX_GDECL const bool & get_enabled() const { return m_enabled.get(); }
    LMX_GDECL lmx::elmx_error set_enabled( const bool & value ) { return m_enabled.set( value ); }

    //    line --> xs:int{0<=x<=3} (Default: 0)
    LMX_GDECL const lmx::tlmx_uns8 & get_line() const { return m_line.get(); }
    LMX_GDECL lmx::elmx_error set_line( const lmx::tlmx_uns8 & value );

    //    onLowToHigh --> xs:boolean (Default: true)
    LMX_GDECL const bool & get_onLowToHigh() const { return m_onLowToHigh.get(); }
    LMX_GDECL lmx::elmx_error set_onLowToHigh( const bool & value ) { return m_onLowToHigh.set( value ); }

    //    delayMS --> xs:int{0<=x<=2147483647} (Default: 0)
    LMX_GDECL const lmx::tlmx_uns32 & get_delayMS() const { return m_delayMS.get(); }
    LMX_GDECL lmx::elmx_error set_delayMS( const lmx::tlmx_uns32 & value );

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ClosureTriggerIn" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ClosureTriggerIn" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Quantitation.xsd(62)
class c_CalibrationAnalyte
{
    //:snippet:start CalibrationAnalyte
    //:snippet:end CalibrationAnalyte

private:
    // Attribute(s)
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_analyteId;

    // Element(s)
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_concentration;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_CalibrationAnalyte();
    LMX_GDECL c_CalibrationAnalyte( const c_CalibrationAnalyte & r_rhs );
    LMX_GDECL c_CalibrationAnalyte & operator = ( const c_CalibrationAnalyte & r_rhs );
    LMX_GDECL virtual c_CalibrationAnalyte * clone() const;
    LMX_GDECL void swap( c_CalibrationAnalyte & r_rhs );
    LMX_GDECL virtual ~c_CalibrationAnalyte();

    // Attribute(s)

    //    analyteId --> xs:IDREF[0..1]
    LMX_GDECL const lmx::tlmx_unicode_string & get_analyteId() const { return m_analyteId.get(); }
    LMX_GDECL lmx::elmx_error set_analyteId( const lmx::tlmx_unicode_string & value ) { return m_analyteId.set( value ); }
    LMX_GDECL bool isset_analyteId() const { return m_analyteId.is_value_set(); }
    LMX_GDECL void unset_analyteId() { m_analyteId.unset(); }
    // Element(s)

    //    concentration --> xs:double[0..1] (Default: -1.0)
    LMX_GDECL const lmx::tlmx_double & get_concentration() const { return m_concentration.get(); }
    LMX_GDECL lmx::elmx_error set_concentration( const lmx::tlmx_double & value ) { return m_concentration.set( value ); }
    LMX_GDECL bool isset_concentration() const { return m_concentration.is_value_set(); }
    LMX_GDECL void unset_concentration();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const
    {
        LMX_NO_WARN_UNUSED( p_tracker_in );
        return true;
    }

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "CalibrationAnalyte" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "CalibrationAnalyte" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_19( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

// From: Quantitation.xsd(124)
class c_SemiQuantIsotope
{
    //:snippet:start SemiQuantIsotope
    //:snippet:end SemiQuantIsotope

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_uns32 > m_atomicNumber;
    lmx::ct_simple_pod_single< lmx::tlmx_uns32 > m_massNumber;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_relativeAtomicMass;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_SemiQuantIsotope();
    LMX_GDECL c_SemiQuantIsotope( const c_SemiQuantIsotope & r_rhs );
    LMX_GDECL c_SemiQuantIsotope & operator = ( const c_SemiQuantIsotope & r_rhs );
    LMX_GDECL virtual c_SemiQuantIsotope * clone() const;
    LMX_GDECL void swap( c_SemiQuantIsotope & r_rhs );
    LMX_GDECL virtual ~c_SemiQuantIsotope();

    // Element(s)

    //    atomicNumber --> xs:int{1<=x<=2147483647}
    LMX_GDECL const lmx::tlmx_uns32 & get_atomicNumber() const { return m_atomicNumber.get(); }
    LMX_GDECL lmx::elmx_error set_atomicNumber( const lmx::tlmx_uns32 & value );

    //    massNumber --> xs:int{1<=x<=2147483647}
    LMX_GDECL const lmx::tlmx_uns32 & get_massNumber() const { return m_massNumber.get(); }
    LMX_GDECL lmx::elmx_error set_massNumber( const lmx::tlmx_uns32 & value );

    //    relativeAtomicMass --> xs:double{0.0<x}
    LMX_GDECL const lmx::tlmx_double & get_relativeAtomicMass() const { return m_relativeAtomicMass.get(); }
    LMX_GDECL lmx::elmx_error set_relativeAtomicMass( const lmx::tlmx_double & value );

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "SemiQuantIsotope" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "SemiQuantIsotope" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_20( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

// From: Quantitation.xsd(166)
class c_QuantScanMode
{
    //:snippet:start QuantScanMode
    //:snippet:end QuantScanMode

private:
    // Attribute(s)
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_id;

    // Element(s)
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_scanModeType;
    lmx::ct_simple_pod_single< lmx::tlmx_int32 > m_sampleListFileIndex;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_QuantScanMode();
    LMX_GDECL c_QuantScanMode( const c_QuantScanMode & r_rhs );
    LMX_GDECL c_QuantScanMode & operator = ( const c_QuantScanMode & r_rhs );
    LMX_GDECL virtual c_QuantScanMode * clone() const;
    LMX_GDECL void swap( c_QuantScanMode & r_rhs );
    LMX_GDECL virtual ~c_QuantScanMode();

    // Attribute(s)

    //    id --> xs:ID[0..1]
    LMX_GDECL const lmx::tlmx_unicode_string & get_id() const { return m_id.get(); }
    LMX_GDECL lmx::elmx_error set_id( const lmx::tlmx_unicode_string & value ) { return m_id.set( value ); }
    LMX_GDECL bool isset_id() const { return m_id.is_value_set(); }
    LMX_GDECL void unset_id() { m_id.unset(); }
    // Element(s)

    //    scanModeType --> xs:string (Default: MS_SIM)
    LMX_GDECL const lmx::tlmx_unicode_string & get_scanModeType() const { return m_scanModeType.get(); }
    LMX_GDECL lmx::elmx_error set_scanModeType( const lmx::tlmx_unicode_string & value );
    enum Method_enum_scanModeType {
            Method_scanModeType_unknown,
            Method_scanModeType__MS_SIM,
            Method_scanModeType__MS_RANGE,
            Method_scanModeType__UV_CHANNEL,
            Method_scanModeType__UV_SPECTRUM };
    LMX_GDECL Method_enum_scanModeType getenum_scanModeType() const;
    LMX_GDECL bool setenum_scanModeType( Method_enum_scanModeType value );
            // Enum options:
            // AdvionObjects::c_QuantScanMode::Method_scanModeType__MS_SIM
            // AdvionObjects::c_QuantScanMode::Method_scanModeType__MS_RANGE
            // AdvionObjects::c_QuantScanMode::Method_scanModeType__UV_CHANNEL
            // AdvionObjects::c_QuantScanMode::Method_scanModeType__UV_SPECTRUM

    //    sampleListFileIndex --> xs:int{-2147483648<=x<=2147483647} (Default: 0)
    LMX_GDECL const lmx::tlmx_int32 & get_sampleListFileIndex() const { return m_sampleListFileIndex.get(); }
    LMX_GDECL lmx::elmx_error set_sampleListFileIndex( const lmx::tlmx_int32 & value );

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "QuantScanMode" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "QuantScanMode" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

class c_GlobalPeakDetection;

// From: PeakDetection.xsd(11)
class c_PeakDetectionType
{
    //:snippet:start PeakDetectionType
    //:snippet:end PeakDetectionType

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_PeakDetectionType();
    LMX_GDECL c_PeakDetectionType( const c_PeakDetectionType & r_rhs );
    LMX_GDECL c_PeakDetectionType & operator = ( const c_PeakDetectionType & r_rhs );
    LMX_GDECL virtual c_PeakDetectionType * clone() const;
    LMX_GDECL void swap( c_PeakDetectionType & r_rhs );
    LMX_GDECL virtual ~c_PeakDetectionType();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id;
    }

    LMX_GDECL static c_PeakDetectionType * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const
    {
        LMX_NO_WARN_UNUSED( p_tracker_in );
        return true;
    }

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "PeakDetectionType" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "PeakDetectionType" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_21( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_22( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

// From: PeakDetection.xsd(53)
class c_IntegrationPoint
{
    //:snippet:start IntegrationPoint
    //:snippet:end IntegrationPoint

private:
    // Element(s)
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_startRetentionTime;
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_retentionTime;
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_height;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_manualHeight;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_IntegrationPoint();
    LMX_GDECL c_IntegrationPoint( const c_IntegrationPoint & r_rhs );
    LMX_GDECL c_IntegrationPoint & operator = ( const c_IntegrationPoint & r_rhs );
    LMX_GDECL virtual c_IntegrationPoint * clone() const;
    LMX_GDECL void swap( c_IntegrationPoint & r_rhs );
    LMX_GDECL virtual ~c_IntegrationPoint();

    // Element(s)

    //    startRetentionTime --> xs:double[0..1]
    LMX_GDECL const lmx::tlmx_double & get_startRetentionTime() const { return m_startRetentionTime.get(); }
    LMX_GDECL lmx::elmx_error set_startRetentionTime( const lmx::tlmx_double & value ) { return m_startRetentionTime.set( value ); }
    LMX_GDECL bool isset_startRetentionTime() const { return m_startRetentionTime.is_value_set(); }
    LMX_GDECL void unset_startRetentionTime() { m_startRetentionTime.unset(); }

    //    retentionTime --> xs:string (Default: Valley)
    LMX_GDECL const lmx::tlmx_unicode_string & get_retentionTime() const { return m_retentionTime.get(); }
    LMX_GDECL lmx::elmx_error set_retentionTime( const lmx::tlmx_unicode_string & value );
    enum Method_enum_retentionTime {
            Method_retentionTime_unknown,
            Method_retentionTime__Valley,
            Method_retentionTime__Baseline,
            Method_retentionTime__Manual };
    LMX_GDECL Method_enum_retentionTime getenum_retentionTime() const;
    LMX_GDECL bool setenum_retentionTime( Method_enum_retentionTime value );
            // Enum options:
            // AdvionObjects::c_IntegrationPoint::Method_retentionTime__Valley
            // AdvionObjects::c_IntegrationPoint::Method_retentionTime__Baseline
            // AdvionObjects::c_IntegrationPoint::Method_retentionTime__Manual

    //    height --> xs:string (Default: DropToBaseline)
    LMX_GDECL const lmx::tlmx_unicode_string & get_height() const { return m_height.get(); }
    LMX_GDECL lmx::elmx_error set_height( const lmx::tlmx_unicode_string & value );
    enum Method_enum_height {
            Method_height_unknown,
            Method_height__DropToBaseline,
            Method_height__OnTrace,
            Method_height__Manual };
    LMX_GDECL Method_enum_height getenum_height() const;
    LMX_GDECL bool setenum_height( Method_enum_height value );
            // Enum options:
            // AdvionObjects::c_IntegrationPoint::Method_height__DropToBaseline
            // AdvionObjects::c_IntegrationPoint::Method_height__OnTrace
            // AdvionObjects::c_IntegrationPoint::Method_height__Manual

    //    manualHeight --> xs:double[0..1]
    LMX_GDECL const lmx::tlmx_double & get_manualHeight() const { return m_manualHeight.get(); }
    LMX_GDECL lmx::elmx_error set_manualHeight( const lmx::tlmx_double & value ) { return m_manualHeight.set( value ); }
    LMX_GDECL bool isset_manualHeight() const { return m_manualHeight.is_value_set(); }
    LMX_GDECL void unset_manualHeight() { m_manualHeight.unset(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "IntegrationPoint" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "IntegrationPoint" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: ProcessMethod.xsd(24)
class c_BackgroundSpectrum
{
    //:snippet:start BackgroundSpectrum
    //:snippet:end BackgroundSpectrum

private:
    // Element(s)
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_startTime;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_endTime;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_BackgroundSpectrum();
    LMX_GDECL c_BackgroundSpectrum( const c_BackgroundSpectrum & r_rhs );
    LMX_GDECL c_BackgroundSpectrum & operator = ( const c_BackgroundSpectrum & r_rhs );
    LMX_GDECL virtual c_BackgroundSpectrum * clone() const;
    LMX_GDECL void swap( c_BackgroundSpectrum & r_rhs );
    LMX_GDECL virtual ~c_BackgroundSpectrum();

    // Element(s)

    //    startTime --> xs:double[0..1] (Default: 0.0)
    LMX_GDECL const lmx::tlmx_double & get_startTime() const { return m_startTime.get(); }
    LMX_GDECL lmx::elmx_error set_startTime( const lmx::tlmx_double & value ) { return m_startTime.set( value ); }
    LMX_GDECL bool isset_startTime() const { return m_startTime.is_value_set(); }
    LMX_GDECL void unset_startTime();

    //    endTime --> xs:double[0..1] (Default: 1000000000.0)
    LMX_GDECL const lmx::tlmx_double & get_endTime() const { return m_endTime.get(); }
    LMX_GDECL lmx::elmx_error set_endTime( const lmx::tlmx_double & value ) { return m_endTime.set( value ); }
    LMX_GDECL bool isset_endTime() const { return m_endTime.is_value_set(); }
    LMX_GDECL void unset_endTime();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const
    {
        LMX_NO_WARN_UNUSED( p_tracker_in );
        return true;
    }

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "BackgroundSpectrum" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "BackgroundSpectrum" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

class c_BoxFilter;

// From: ProcessMethod.xsd(113)
class c_Filter
{
    //:snippet:start Filter
    //:snippet:end Filter

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_Filter();
    LMX_GDECL c_Filter( const c_Filter & r_rhs );
    LMX_GDECL c_Filter & operator = ( const c_Filter & r_rhs );
    LMX_GDECL virtual c_Filter * clone() const;
    LMX_GDECL void swap( c_Filter & r_rhs );
    LMX_GDECL virtual ~c_Filter();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id;
    }

    LMX_GDECL static c_Filter * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const
    {
        LMX_NO_WARN_UNUSED( p_tracker_in );
        return true;
    }

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "Filter" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "Filter" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: ProcessMethod.xsd(114)
class c_BoxFilter : public c_Filter
{
    //:snippet:start BoxFilter
    //:snippet:end BoxFilter

private:
    // Element(s)
    lmx::ct_simple_pod_optional< lmx::tlmx_int32 > m_width;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_BoxFilter();
    LMX_GDECL c_BoxFilter( const c_BoxFilter & r_rhs );
    LMX_GDECL c_BoxFilter & operator = ( const c_BoxFilter & r_rhs );
    LMX_GDECL virtual c_BoxFilter * clone() const;
    LMX_GDECL void swap( c_BoxFilter & r_rhs );
    LMX_GDECL virtual ~c_BoxFilter();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_Filter::has_id( id_in );
    }

    // Element(s)

    //    width --> xs:int{-2147483648<=x<=2147483647}[0..1] (Default: 3)
    LMX_GDECL const lmx::tlmx_int32 & get_width() const { return m_width.get(); }
    LMX_GDECL lmx::elmx_error set_width( const lmx::tlmx_int32 & value );
    LMX_GDECL bool isset_width() const { return m_width.is_value_set(); }
    LMX_GDECL void unset_width();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "BoxFilter" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "BoxFilter" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_23( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

// From: Method.xsd(40)
class c_RangeScanMode : public c_ScanMode
{
    //:snippet:start RangeScanMode
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end RangeScanMode

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_start;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_end;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_scanTime;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_scanDelay;
    lmx::ct_complex_optional< c_DeltaBackgroundParameters > m_deltaBackgroundParameters;
    lmx::ct_simple_pod_optional< bool > m_useTwoIonSourceOptimizations;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_RangeScanMode();
    LMX_GDECL c_RangeScanMode( const c_RangeScanMode & r_rhs );
    LMX_GDECL c_RangeScanMode & operator = ( const c_RangeScanMode & r_rhs );
    LMX_GDECL virtual c_RangeScanMode * clone() const;
    LMX_GDECL void swap( c_RangeScanMode & r_rhs );
    LMX_GDECL virtual ~c_RangeScanMode();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ScanMode::has_id( id_in );
    }

    // Element(s)

    //    start --> xs:double{10<=x<=2000} (Default: 100)
    LMX_GDECL const lmx::tlmx_double & get_start() const { return m_start.get(); }
    LMX_GDECL lmx::elmx_error set_start( const lmx::tlmx_double & value );

    //    end --> xs:double{10<=x<=2000} (Default: 1200)
    LMX_GDECL const lmx::tlmx_double & get_end() const { return m_end.get(); }
    LMX_GDECL lmx::elmx_error set_end( const lmx::tlmx_double & value );

    //    scanTime --> xs:double{50<=x<=5000} (Default: 1000)
    LMX_GDECL const lmx::tlmx_double & get_scanTime() const { return m_scanTime.get(); }
    LMX_GDECL lmx::elmx_error set_scanTime( const lmx::tlmx_double & value );

    //    scanDelay --> xs:double{0<=x} (Default: 10)
    LMX_GDECL const lmx::tlmx_double & get_scanDelay() const { return m_scanDelay.get(); }
    LMX_GDECL lmx::elmx_error set_scanDelay( const lmx::tlmx_double & value );

    //    deltaBackgroundParameters --> DeltaBackgroundParameters[0..1]
    LMX_GDECL const c_DeltaBackgroundParameters & get_deltaBackgroundParameters() const { return m_deltaBackgroundParameters.get(); }
    LMX_GDECL c_DeltaBackgroundParameters & get_deltaBackgroundParameters() { return m_deltaBackgroundParameters.get(); } // For read/write access
    LMX_GDECL c_DeltaBackgroundParameters & assign_deltaBackgroundParameters( const c_DeltaBackgroundParameters & value ) { return (get_deltaBackgroundParameters() = value); }
    LMX_GDECL c_DeltaBackgroundParameters & assign_deltaBackgroundParameters( c_DeltaBackgroundParameters * p ) { return m_deltaBackgroundParameters.assign( p ); }
    LMX_GDECL bool isset_deltaBackgroundParameters() const { return m_deltaBackgroundParameters.is_value_set(); }
    LMX_GDECL void unset_deltaBackgroundParameters() { m_deltaBackgroundParameters.unset(); }

    //    useTwoIonSourceOptimizations --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_useTwoIonSourceOptimizations() const { return m_useTwoIonSourceOptimizations.get(); }
    LMX_GDECL lmx::elmx_error set_useTwoIonSourceOptimizations( const bool & value ) { return m_useTwoIonSourceOptimizations.set( value ); }
    LMX_GDECL bool isset_useTwoIonSourceOptimizations() const { return m_useTwoIonSourceOptimizations.is_value_set(); }
    LMX_GDECL void unset_useTwoIonSourceOptimizations();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "RangeScanMode" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "RangeScanMode" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(124)
class c_SIMScanMode : public c_ScanMode
{
    //:snippet:start SIMScanMode
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end SIMScanMode

private:
    // Element(s)
    lmx::ct_complex_multi< c_MassOfInterest > m_massOfInterest;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_SIMScanMode();
    LMX_GDECL c_SIMScanMode( const c_SIMScanMode & r_rhs );
    LMX_GDECL c_SIMScanMode & operator = ( const c_SIMScanMode & r_rhs );
    LMX_GDECL virtual c_SIMScanMode * clone() const;
    LMX_GDECL void swap( c_SIMScanMode & r_rhs );
    LMX_GDECL virtual ~c_SIMScanMode();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ScanMode::has_id( id_in );
    }

    // Element(s)

    //    massOfInterest --> MassOfInterest[0..*]
    LMX_GDECL const c_MassOfInterest & get_massOfInterest( size_t index ) const { return m_massOfInterest.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_massOfInterest() { return append_massOfInterest( new c_MassOfInterest ); }            // For write access
    LMX_GDECL lmx::elmx_error append_massOfInterest( c_MassOfInterest * p_value ) // For write access
    {
        lmx::uniq_ptr< c_MassOfInterest >::type auto_p_value( p_value );
        m_massOfInterest.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_MassOfInterest & back_massOfInterest() { return m_massOfInterest.back(); }           // For write access
    LMX_GDECL lmx::elmx_error insert_massOfInterest( size_t index ) { return insert_massOfInterest( index, new c_MassOfInterest ); } // For write access
    LMX_GDECL lmx::elmx_error insert_massOfInterest( size_t index, c_MassOfInterest * p_value ) // For write access
    {
        lmx::uniq_ptr< c_MassOfInterest >::type auto_p_value( p_value );
        m_massOfInterest.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_MassOfInterest & get_massOfInterest( size_t index ) { return m_massOfInterest.get( index ); } // For read/write access
    LMX_GDECL void delete_massOfInterest( size_t index )
    {
        lmx_assert( index < m_massOfInterest.size() );
        m_massOfInterest.erase( index );
    }
    LMX_GDECL void clear_massOfInterest() { m_massOfInterest.clear(); }
    LMX_GDECL c_MassOfInterest & assign_massOfInterest( size_t index, const c_MassOfInterest & value ) { return get_massOfInterest( index ) = value; } // Deep Copy
    LMX_GDECL c_MassOfInterest & assign_massOfInterest( size_t index, c_MassOfInterest * p ) { return m_massOfInterest.assign( index, p ); }
    LMX_GDECL size_t size_massOfInterest() const { return m_massOfInterest.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "SIMScanMode" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "SIMScanMode" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

class c_TimeBaselineRemoval;

// From: Method.xsd(215)
class c_BaselineRemoval
{
    //:snippet:start BaselineRemoval
    //:snippet:end BaselineRemoval

private:
    // Element(s)
    lmx::ct_simple_pod_single< bool > m_enabled;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_BaselineRemoval();
    LMX_GDECL c_BaselineRemoval( const c_BaselineRemoval & r_rhs );
    LMX_GDECL c_BaselineRemoval & operator = ( const c_BaselineRemoval & r_rhs );
    LMX_GDECL virtual c_BaselineRemoval * clone() const;
    LMX_GDECL void swap( c_BaselineRemoval & r_rhs );
    LMX_GDECL virtual ~c_BaselineRemoval();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id;
    }

    LMX_GDECL static c_BaselineRemoval * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    //    enabled --> xs:boolean (Default: false)
    LMX_GDECL const bool & get_enabled() const { return m_enabled.get(); }
    LMX_GDECL lmx::elmx_error set_enabled( const bool & value ) { return m_enabled.set( value ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "BaselineRemoval" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "BaselineRemoval" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(220)
class c_TimeBaselineRemoval : public c_BaselineRemoval
{
    //:snippet:start TimeBaselineRemoval
    //:snippet:end TimeBaselineRemoval

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_time;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_span;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_TimeBaselineRemoval();
    LMX_GDECL c_TimeBaselineRemoval( const c_TimeBaselineRemoval & r_rhs );
    LMX_GDECL c_TimeBaselineRemoval & operator = ( const c_TimeBaselineRemoval & r_rhs );
    LMX_GDECL virtual c_TimeBaselineRemoval * clone() const;
    LMX_GDECL void swap( c_TimeBaselineRemoval & r_rhs );
    LMX_GDECL virtual ~c_TimeBaselineRemoval();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_BaselineRemoval::has_id( id_in );
    }

    // Element(s)

    //    time --> xs:double (Default: 1.0)
    LMX_GDECL const lmx::tlmx_double & get_time() const { return m_time.get(); }
    LMX_GDECL lmx::elmx_error set_time( const lmx::tlmx_double & value ) { return m_time.set( value ); }

    //    span --> xs:double (Default: 1.0)
    LMX_GDECL const lmx::tlmx_double & get_span() const { return m_span.get(); }
    LMX_GDECL lmx::elmx_error set_span( const lmx::tlmx_double & value ) { return m_span.set( value ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "TimeBaselineRemoval" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "TimeBaselineRemoval" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

class c_TriangleAnalogOutputSmoothing;

// From: Method.xsd(230)
class c_AnalogOutputSmoothing
{
    //:snippet:start AnalogOutputSmoothing
    //:snippet:end AnalogOutputSmoothing

private:
    // Element(s)
    lmx::ct_simple_pod_single< bool > m_enabled;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_AnalogOutputSmoothing();
    LMX_GDECL c_AnalogOutputSmoothing( const c_AnalogOutputSmoothing & r_rhs );
    LMX_GDECL c_AnalogOutputSmoothing & operator = ( const c_AnalogOutputSmoothing & r_rhs );
    LMX_GDECL virtual c_AnalogOutputSmoothing * clone() const;
    LMX_GDECL void swap( c_AnalogOutputSmoothing & r_rhs );
    LMX_GDECL virtual ~c_AnalogOutputSmoothing();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id;
    }

    LMX_GDECL static c_AnalogOutputSmoothing * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    //    enabled --> xs:boolean (Default: false)
    LMX_GDECL const bool & get_enabled() const { return m_enabled.get(); }
    LMX_GDECL lmx::elmx_error set_enabled( const bool & value ) { return m_enabled.set( value ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "AnalogOutputSmoothing" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "AnalogOutputSmoothing" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(235)
class c_TriangleAnalogOutputSmoothing : public c_AnalogOutputSmoothing
{
    //:snippet:start TriangleAnalogOutputSmoothing
    //:snippet:end TriangleAnalogOutputSmoothing

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_time;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_TriangleAnalogOutputSmoothing();
    LMX_GDECL c_TriangleAnalogOutputSmoothing( const c_TriangleAnalogOutputSmoothing & r_rhs );
    LMX_GDECL c_TriangleAnalogOutputSmoothing & operator = ( const c_TriangleAnalogOutputSmoothing & r_rhs );
    LMX_GDECL virtual c_TriangleAnalogOutputSmoothing * clone() const;
    LMX_GDECL void swap( c_TriangleAnalogOutputSmoothing & r_rhs );
    LMX_GDECL virtual ~c_TriangleAnalogOutputSmoothing();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_AnalogOutputSmoothing::has_id( id_in );
    }

    // Element(s)

    //    time --> xs:double (Default: 5.0)
    LMX_GDECL const lmx::tlmx_double & get_time() const { return m_time.get(); }
    LMX_GDECL lmx::elmx_error set_time( const lmx::tlmx_double & value ) { return m_time.set( value ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "TriangleAnalogOutputSmoothing" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "TriangleAnalogOutputSmoothing" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

class c_SIMAnalogOutput;
class c_XICAnalogOutput;
class c_TICAnalogOutput;
class c_DeltaICAnalogOutput;
class c_DeltaXICAnalogOutput;

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_24( const lmx::tlmx_uns8 &, const char * );
#endif // LMX_USER_VALIDATE

// From: Method.xsd(244)
class c_AnalogOutput
{
    //:snippet:start AnalogOutput
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end AnalogOutput

private:
    // Element(s)
    lmx::ct_simple_pod_single< bool > m_enabled;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_maxIntensity;
    lmx::ct_simple_pod_single< lmx::tlmx_uns8 > m_maxVoltage;
    lmx::ct_complex_optional< c_BaselineRemoval > m_baselineRemoval;
    lmx::ct_complex_optional< c_AnalogOutputSmoothing > m_smoothing;
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_source;
    lmx::ct_simple_pod_optional< lmx::tlmx_uns32 > m_scanModeIndex;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_AnalogOutput();
    LMX_GDECL c_AnalogOutput( const c_AnalogOutput & r_rhs );
    LMX_GDECL c_AnalogOutput & operator = ( const c_AnalogOutput & r_rhs );
    LMX_GDECL virtual c_AnalogOutput * clone() const;
    LMX_GDECL void swap( c_AnalogOutput & r_rhs );
    LMX_GDECL virtual ~c_AnalogOutput();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id;
    }

    LMX_GDECL static c_AnalogOutput * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    //    enabled --> xs:boolean (Default: false)
    LMX_GDECL const bool & get_enabled() const { return m_enabled.get(); }
    LMX_GDECL lmx::elmx_error set_enabled( const bool & value ) { return m_enabled.set( value ); }

    //    maxIntensity --> xs:double (Default: 1000000000.0)
    LMX_GDECL const lmx::tlmx_double & get_maxIntensity() const { return m_maxIntensity.get(); }
    LMX_GDECL lmx::elmx_error set_maxIntensity( const lmx::tlmx_double & value ) { return m_maxIntensity.set( value ); }

    //    maxVoltage --> xs:int{1<=x<=10} (Default: 1)
    LMX_GDECL const lmx::tlmx_uns8 & get_maxVoltage() const { return m_maxVoltage.get(); }
    LMX_GDECL lmx::elmx_error set_maxVoltage( const lmx::tlmx_uns8 & value );

    //    baselineRemoval --> BaselineRemoval[0..1]
    LMX_GDECL const c_BaselineRemoval & get_baselineRemoval() const { return m_baselineRemoval.get(); }
    LMX_GDECL c_BaselineRemoval & get_baselineRemoval() { return m_baselineRemoval.get(); } // For read/write access
    LMX_GDECL c_BaselineRemoval & assign_baselineRemoval( const c_BaselineRemoval & value ) { return (get_baselineRemoval() = value); }
    LMX_GDECL c_BaselineRemoval & assign_baselineRemoval( c_BaselineRemoval * p ) { return m_baselineRemoval.assign( p ); }
    LMX_GDECL bool isset_baselineRemoval() const { return m_baselineRemoval.is_value_set(); }
    LMX_GDECL void unset_baselineRemoval() { m_baselineRemoval.unset(); }

    //    smoothing --> AnalogOutputSmoothing[0..1]
    LMX_GDECL const c_AnalogOutputSmoothing & get_smoothing() const { return m_smoothing.get(); }
    LMX_GDECL c_AnalogOutputSmoothing & get_smoothing() { return m_smoothing.get(); } // For read/write access
    LMX_GDECL c_AnalogOutputSmoothing & assign_smoothing( const c_AnalogOutputSmoothing & value ) { return (get_smoothing() = value); }
    LMX_GDECL c_AnalogOutputSmoothing & assign_smoothing( c_AnalogOutputSmoothing * p ) { return m_smoothing.assign( p ); }
    LMX_GDECL bool isset_smoothing() const { return m_smoothing.is_value_set(); }
    LMX_GDECL void unset_smoothing() { m_smoothing.unset(); }

    //    source --> xs:string[0..1] (Default: First)
    LMX_GDECL const lmx::tlmx_unicode_string & get_source() const { return m_source.get(); }
    LMX_GDECL lmx::elmx_error set_source( const lmx::tlmx_unicode_string & value );
    enum Method_enum_source {
            Method_source_unknown,
            Method_source__First,
            Method_source__Second };
    LMX_GDECL Method_enum_source getenum_source() const;
    LMX_GDECL bool setenum_source( Method_enum_source value );
            // Enum options:
            // AdvionObjects::c_AnalogOutput::Method_source__First
            // AdvionObjects::c_AnalogOutput::Method_source__Second
    LMX_GDECL bool isset_source() const { return m_source.is_value_set(); }
    LMX_GDECL void unset_source();

    //    scanModeIndex --> xs:int{0<=x<=2147483647}[0..1] (Default: 0)
    LMX_GDECL const lmx::tlmx_uns32 & get_scanModeIndex() const { return m_scanModeIndex.get(); }
    LMX_GDECL lmx::elmx_error set_scanModeIndex( const lmx::tlmx_uns32 & value );
    LMX_GDECL bool isset_scanModeIndex() const { return m_scanModeIndex.is_value_set(); }
    LMX_GDECL void unset_scanModeIndex();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "AnalogOutput" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "AnalogOutput" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(268)
class c_TICAnalogOutput : public c_AnalogOutput
{
    //:snippet:start TICAnalogOutput
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end TICAnalogOutput

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_TICAnalogOutput();
    LMX_GDECL c_TICAnalogOutput( const c_TICAnalogOutput & r_rhs );
    LMX_GDECL c_TICAnalogOutput & operator = ( const c_TICAnalogOutput & r_rhs );
    LMX_GDECL virtual c_TICAnalogOutput * clone() const;
    LMX_GDECL void swap( c_TICAnalogOutput & r_rhs );
    LMX_GDECL virtual ~c_TICAnalogOutput();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_AnalogOutput::has_id( id_in );
    }

    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "TICAnalogOutput" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "TICAnalogOutput" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

class c_XICAnalogOutput;
class c_DeltaXICAnalogOutput;

// From: Method.xsd(273)
class c_ExtractedAnalogOutput : public c_AnalogOutput
{
    //:snippet:start ExtractedAnalogOutput
    //:snippet:end ExtractedAnalogOutput

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_startMass;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_endMass;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ExtractedAnalogOutput();
    LMX_GDECL c_ExtractedAnalogOutput( const c_ExtractedAnalogOutput & r_rhs );
    LMX_GDECL c_ExtractedAnalogOutput & operator = ( const c_ExtractedAnalogOutput & r_rhs );
    LMX_GDECL virtual c_ExtractedAnalogOutput * clone() const;
    LMX_GDECL void swap( c_ExtractedAnalogOutput & r_rhs );
    LMX_GDECL virtual ~c_ExtractedAnalogOutput();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_AnalogOutput::has_id( id_in );
    }

    LMX_GDECL static c_ExtractedAnalogOutput * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    //    startMass --> xs:double (Default: 499.5)
    LMX_GDECL const lmx::tlmx_double & get_startMass() const { return m_startMass.get(); }
    LMX_GDECL lmx::elmx_error set_startMass( const lmx::tlmx_double & value ) { return m_startMass.set( value ); }

    //    endMass --> xs:double (Default: 500.5)
    LMX_GDECL const lmx::tlmx_double & get_endMass() const { return m_endMass.get(); }
    LMX_GDECL lmx::elmx_error set_endMass( const lmx::tlmx_double & value ) { return m_endMass.set( value ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ExtractedAnalogOutput" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ExtractedAnalogOutput" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(283)
class c_XICAnalogOutput : public c_ExtractedAnalogOutput
{
    //:snippet:start XICAnalogOutput
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end XICAnalogOutput

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_XICAnalogOutput();
    LMX_GDECL c_XICAnalogOutput( const c_XICAnalogOutput & r_rhs );
    LMX_GDECL c_XICAnalogOutput & operator = ( const c_XICAnalogOutput & r_rhs );
    LMX_GDECL virtual c_XICAnalogOutput * clone() const;
    LMX_GDECL void swap( c_XICAnalogOutput & r_rhs );
    LMX_GDECL virtual ~c_XICAnalogOutput();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ExtractedAnalogOutput::has_id( id_in );
    }

    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "XICAnalogOutput" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "XICAnalogOutput" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(288)
class c_SIMAnalogOutput : public c_AnalogOutput
{
    //:snippet:start SIMAnalogOutput
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end SIMAnalogOutput

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_uns32 > m_simIndex;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_SIMAnalogOutput();
    LMX_GDECL c_SIMAnalogOutput( const c_SIMAnalogOutput & r_rhs );
    LMX_GDECL c_SIMAnalogOutput & operator = ( const c_SIMAnalogOutput & r_rhs );
    LMX_GDECL virtual c_SIMAnalogOutput * clone() const;
    LMX_GDECL void swap( c_SIMAnalogOutput & r_rhs );
    LMX_GDECL virtual ~c_SIMAnalogOutput();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_AnalogOutput::has_id( id_in );
    }

    // Element(s)

    //    simIndex --> xs:int{0<=x<=2147483647} (Default: 0)
    LMX_GDECL const lmx::tlmx_uns32 & get_simIndex() const { return m_simIndex.get(); }
    LMX_GDECL lmx::elmx_error set_simIndex( const lmx::tlmx_uns32 & value );

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "SIMAnalogOutput" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "SIMAnalogOutput" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(303)
class c_DeltaICAnalogOutput : public c_AnalogOutput
{
    //:snippet:start DeltaICAnalogOutput
    //:snippet:end DeltaICAnalogOutput

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_DeltaICAnalogOutput();
    LMX_GDECL c_DeltaICAnalogOutput( const c_DeltaICAnalogOutput & r_rhs );
    LMX_GDECL c_DeltaICAnalogOutput & operator = ( const c_DeltaICAnalogOutput & r_rhs );
    LMX_GDECL virtual c_DeltaICAnalogOutput * clone() const;
    LMX_GDECL void swap( c_DeltaICAnalogOutput & r_rhs );
    LMX_GDECL virtual ~c_DeltaICAnalogOutput();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_AnalogOutput::has_id( id_in );
    }

    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "DeltaICAnalogOutput" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "DeltaICAnalogOutput" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(308)
class c_DeltaXICAnalogOutput : public c_ExtractedAnalogOutput
{
    //:snippet:start DeltaXICAnalogOutput
    //:snippet:end DeltaXICAnalogOutput

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_DeltaXICAnalogOutput();
    LMX_GDECL c_DeltaXICAnalogOutput( const c_DeltaXICAnalogOutput & r_rhs );
    LMX_GDECL c_DeltaXICAnalogOutput & operator = ( const c_DeltaXICAnalogOutput & r_rhs );
    LMX_GDECL virtual c_DeltaXICAnalogOutput * clone() const;
    LMX_GDECL void swap( c_DeltaXICAnalogOutput & r_rhs );
    LMX_GDECL virtual ~c_DeltaXICAnalogOutput();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ExtractedAnalogOutput::has_id( id_in );
    }

    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "DeltaXICAnalogOutput" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "DeltaXICAnalogOutput" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(313)
class c_AnalogInputs
{
    //:snippet:start AnalogInputs
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end AnalogInputs

private:
    // Element(s)
    lmx::ct_complex_multi< c_AnalogInput > m_input;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_AnalogInputs();
    LMX_GDECL c_AnalogInputs( const c_AnalogInputs & r_rhs );
    LMX_GDECL c_AnalogInputs & operator = ( const c_AnalogInputs & r_rhs );
    LMX_GDECL virtual c_AnalogInputs * clone() const;
    LMX_GDECL void swap( c_AnalogInputs & r_rhs );
    LMX_GDECL virtual ~c_AnalogInputs();

    // Element(s)

    //    input --> AnalogInput[4]
    LMX_GDECL const c_AnalogInput & get_input( size_t index ) const { return m_input.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_input() { return append_input( new c_AnalogInput ); }                     // For write access
    LMX_GDECL lmx::elmx_error append_input( c_AnalogInput * p_value ); // For write access
    LMX_GDECL c_AnalogInput & back_input() { return m_input.back(); }                       // For write access
    LMX_GDECL lmx::elmx_error insert_input( size_t index ) { return insert_input( index, new c_AnalogInput ); }       // For write access
    LMX_GDECL lmx::elmx_error insert_input( size_t index, c_AnalogInput * p_value ); // For write access
    LMX_GDECL c_AnalogInput & get_input( size_t index )      // For read/write access
    {
        lmx_assert( index < 4 );
        return m_input.get( index );
    }
    LMX_GDECL void delete_input( size_t index )
    {
        lmx_assert( index < m_input.size() );
        m_input.erase( index );
    }
    LMX_GDECL void clear_input() { m_input.clear(); }
    LMX_GDECL c_AnalogInput & assign_input( size_t index, const c_AnalogInput & value ) { return get_input( index ) = value; } // Deep Copy
    LMX_GDECL c_AnalogInput & assign_input( size_t index, c_AnalogInput * p ) { return m_input.assign( index, p ); }
    LMX_GDECL size_t size_input() const { return m_input.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "AnalogInputs" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "AnalogInputs" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(339)
class c_ContactClosureOut
{
    //:snippet:start ContactClosureOut
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end ContactClosureOut

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_uns8 > m_line;
    lmx::ct_complex_single< c_ClosureOutTrigger > m_closeTrigger;
    lmx::ct_complex_single< c_ClosureOutTrigger > m_openTrigger;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ContactClosureOut();
    LMX_GDECL c_ContactClosureOut( const c_ContactClosureOut & r_rhs );
    LMX_GDECL c_ContactClosureOut & operator = ( const c_ContactClosureOut & r_rhs );
    LMX_GDECL virtual c_ContactClosureOut * clone() const;
    LMX_GDECL void swap( c_ContactClosureOut & r_rhs );
    LMX_GDECL virtual ~c_ContactClosureOut();

    // Element(s)

    //    line --> xs:int{0<=x<=3} (Default: 0)
    LMX_GDECL const lmx::tlmx_uns8 & get_line() const { return m_line.get(); }
    LMX_GDECL lmx::elmx_error set_line( const lmx::tlmx_uns8 & value );

    //    closeTrigger --> ClosureOutTrigger
    LMX_GDECL const c_ClosureOutTrigger & get_closeTrigger() const { return m_closeTrigger.get(); }
    LMX_GDECL c_ClosureOutTrigger & get_closeTrigger() { return m_closeTrigger.get(); } // For read/write access
    LMX_GDECL c_ClosureOutTrigger & assign_closeTrigger( const c_ClosureOutTrigger & value ) { return (get_closeTrigger() = value); }
    LMX_GDECL c_ClosureOutTrigger & assign_closeTrigger( c_ClosureOutTrigger * p ) { return m_closeTrigger.assign( p ); }

    //    openTrigger --> ClosureOutTrigger
    LMX_GDECL const c_ClosureOutTrigger & get_openTrigger() const { return m_openTrigger.get(); }
    LMX_GDECL c_ClosureOutTrigger & get_openTrigger() { return m_openTrigger.get(); } // For read/write access
    LMX_GDECL c_ClosureOutTrigger & assign_openTrigger( const c_ClosureOutTrigger & value ) { return (get_openTrigger() = value); }
    LMX_GDECL c_ClosureOutTrigger & assign_openTrigger( c_ClosureOutTrigger * p ) { return m_openTrigger.assign( p ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ContactClosureOut" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ContactClosureOut" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: MethodCommon.xsd(3)
class c_ContactClosureIn
{
    //:snippet:start ContactClosureIn
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end ContactClosureIn

private:
    // Element(s)
    lmx::ct_complex_single< c_ClosureTriggerIn > m_start;
    lmx::ct_complex_single< c_ClosureTriggerIn > m_stop;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ContactClosureIn();
    LMX_GDECL c_ContactClosureIn( const c_ContactClosureIn & r_rhs );
    LMX_GDECL c_ContactClosureIn & operator = ( const c_ContactClosureIn & r_rhs );
    LMX_GDECL virtual c_ContactClosureIn * clone() const;
    LMX_GDECL void swap( c_ContactClosureIn & r_rhs );
    LMX_GDECL virtual ~c_ContactClosureIn();

    // Element(s)

    //    start --> ClosureTriggerIn
    LMX_GDECL const c_ClosureTriggerIn & get_start() const { return m_start.get(); }
    LMX_GDECL c_ClosureTriggerIn & get_start() { return m_start.get(); } // For read/write access
    LMX_GDECL c_ClosureTriggerIn & assign_start( const c_ClosureTriggerIn & value ) { return (get_start() = value); }
    LMX_GDECL c_ClosureTriggerIn & assign_start( c_ClosureTriggerIn * p ) { return m_start.assign( p ); }

    //    stop --> ClosureTriggerIn
    LMX_GDECL const c_ClosureTriggerIn & get_stop() const { return m_stop.get(); }
    LMX_GDECL c_ClosureTriggerIn & get_stop() { return m_stop.get(); } // For read/write access
    LMX_GDECL c_ClosureTriggerIn & assign_stop( const c_ClosureTriggerIn & value ) { return (get_stop() = value); }
    LMX_GDECL c_ClosureTriggerIn & assign_stop( c_ClosureTriggerIn * p ) { return m_stop.assign( p ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ContactClosureIn" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ContactClosureIn" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_25( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

// From: Quantitation.xsd(44)
class c_CalibrationStandard
{
    //:snippet:start CalibrationStandard
    //:snippet:end CalibrationStandard

private:
    // Attribute(s)
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_id;
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_type;

    // Element(s)
    lmx::ct_complex_multi< c_CalibrationAnalyte > m_calibrationAnalyte;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_CalibrationStandard();
    LMX_GDECL c_CalibrationStandard( const c_CalibrationStandard & r_rhs );
    LMX_GDECL c_CalibrationStandard & operator = ( const c_CalibrationStandard & r_rhs );
    LMX_GDECL virtual c_CalibrationStandard * clone() const;
    LMX_GDECL void swap( c_CalibrationStandard & r_rhs );
    LMX_GDECL virtual ~c_CalibrationStandard();

    // Attribute(s)

    //    id --> xs:ID[0..1]
    LMX_GDECL const lmx::tlmx_unicode_string & get_id() const { return m_id.get(); }
    LMX_GDECL lmx::elmx_error set_id( const lmx::tlmx_unicode_string & value ) { return m_id.set( value ); }
    LMX_GDECL bool isset_id() const { return m_id.is_value_set(); }
    LMX_GDECL void unset_id() { m_id.unset(); }

    //    type --> xs:string[0..1] (Default: Calibration)
    LMX_GDECL const lmx::tlmx_unicode_string & get_type() const { return m_type.get(); }
    LMX_GDECL lmx::elmx_error set_type( const lmx::tlmx_unicode_string & value );
    enum Method_enum_type {
            Method_type_unknown,
            Method_type__Unknown,
            Method_type__Blank,
            Method_type__Background,
            Method_type__Calibration,
            Method_type__QC };
    LMX_GDECL Method_enum_type getenum_type() const;
    LMX_GDECL bool setenum_type( Method_enum_type value );
            // Enum options:
            // AdvionObjects::c_CalibrationStandard::Method_type__Unknown
            // AdvionObjects::c_CalibrationStandard::Method_type__Blank
            // AdvionObjects::c_CalibrationStandard::Method_type__Background
            // AdvionObjects::c_CalibrationStandard::Method_type__Calibration
            // AdvionObjects::c_CalibrationStandard::Method_type__QC
    LMX_GDECL bool isset_type() const { return m_type.is_value_set(); }
    LMX_GDECL void unset_type();
    // Element(s)

    //    calibrationAnalyte --> CalibrationAnalyte[0..*]
    LMX_GDECL const c_CalibrationAnalyte & get_calibrationAnalyte( size_t index ) const { return m_calibrationAnalyte.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_calibrationAnalyte() { return append_calibrationAnalyte( new c_CalibrationAnalyte ); }        // For write access
    LMX_GDECL lmx::elmx_error append_calibrationAnalyte( c_CalibrationAnalyte * p_value ) // For write access
    {
        lmx::uniq_ptr< c_CalibrationAnalyte >::type auto_p_value( p_value );
        m_calibrationAnalyte.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_CalibrationAnalyte & back_calibrationAnalyte() { return m_calibrationAnalyte.back(); }   // For write access
    LMX_GDECL lmx::elmx_error insert_calibrationAnalyte( size_t index ) { return insert_calibrationAnalyte( index, new c_CalibrationAnalyte ); } // For write access
    LMX_GDECL lmx::elmx_error insert_calibrationAnalyte( size_t index, c_CalibrationAnalyte * p_value ) // For write access
    {
        lmx::uniq_ptr< c_CalibrationAnalyte >::type auto_p_value( p_value );
        m_calibrationAnalyte.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_CalibrationAnalyte & get_calibrationAnalyte( size_t index ) { return m_calibrationAnalyte.get( index ); } // For read/write access
    LMX_GDECL void delete_calibrationAnalyte( size_t index )
    {
        lmx_assert( index < m_calibrationAnalyte.size() );
        m_calibrationAnalyte.erase( index );
    }
    LMX_GDECL void clear_calibrationAnalyte() { m_calibrationAnalyte.clear(); }
    LMX_GDECL c_CalibrationAnalyte & assign_calibrationAnalyte( size_t index, const c_CalibrationAnalyte & value ) { return get_calibrationAnalyte( index ) = value; } // Deep Copy
    LMX_GDECL c_CalibrationAnalyte & assign_calibrationAnalyte( size_t index, c_CalibrationAnalyte * p ) { return m_calibrationAnalyte.assign( index, p ); }
    LMX_GDECL size_t size_calibrationAnalyte() const { return m_calibrationAnalyte.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const
    {
        LMX_NO_WARN_UNUSED( p_tracker_in );
        return true;
    }

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "CalibrationStandard" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "CalibrationStandard" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Quantitation.xsd(109)
class c_SemiQuantStandard
{
    //:snippet:start SemiQuantStandard
    //:snippet:end SemiQuantStandard

private:
    // Element(s)
    lmx::ct_complex_single< c_SemiQuantIsotope > m_isotope;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_concentration;
    lmx::ct_simple_pod_multi< lmx::tlmx_double > m_intensity;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_SemiQuantStandard();
    LMX_GDECL c_SemiQuantStandard( const c_SemiQuantStandard & r_rhs );
    LMX_GDECL c_SemiQuantStandard & operator = ( const c_SemiQuantStandard & r_rhs );
    LMX_GDECL virtual c_SemiQuantStandard * clone() const;
    LMX_GDECL void swap( c_SemiQuantStandard & r_rhs );
    LMX_GDECL virtual ~c_SemiQuantStandard();

    // Element(s)

    //    isotope --> SemiQuantIsotope
    LMX_GDECL const c_SemiQuantIsotope & get_isotope() const { return m_isotope.get(); }
    LMX_GDECL c_SemiQuantIsotope & get_isotope() { return m_isotope.get(); } // For read/write access
    LMX_GDECL c_SemiQuantIsotope & assign_isotope( const c_SemiQuantIsotope & value ) { return (get_isotope() = value); }
    LMX_GDECL c_SemiQuantIsotope & assign_isotope( c_SemiQuantIsotope * p ) { return m_isotope.assign( p ); }

    //    concentration --> xs:double
    LMX_GDECL const lmx::tlmx_double & get_concentration() const { return m_concentration.get(); }
    LMX_GDECL lmx::elmx_error set_concentration( const lmx::tlmx_double & value ) { return m_concentration.set( value ); }

    //    intensity --> xs:double[1..*]
    LMX_GDECL const lmx::tlmx_double & get_intensity( size_t index ) const { return m_intensity.get( index ); }
    LMX_GDECL lmx::elmx_error set_intensity( size_t index, const lmx::tlmx_double & value ) { return m_intensity.set( index, value ); }
    LMX_GDECL lmx::elmx_error append_intensity( const lmx::tlmx_double & value )
    {
        m_intensity.append( value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL lmx::elmx_error insert_intensity( size_t index, const lmx::tlmx_double & value )
    {
        m_intensity.insert( index, value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL void delete_intensity( size_t index ) { m_intensity.erase( index ); }
    LMX_GDECL void clear_intensity() { m_intensity.clear(); }
    LMX_GDECL size_t size_intensity() const { return m_intensity.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "SemiQuantStandard" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "SemiQuantStandard" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_26( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_27( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

// From: Analyte.xsd(83)
class c_AnalyteSettings
{
    //:snippet:start AnalyteSettings
    //:snippet:end AnalyteSettings

private:
    // Attribute(s)
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_id;
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_scanModeId;
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_referenceAnalyteId;
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_internalStandardId;
    lmx::ct_simple_pod_optional< lmx::tlmx_int32 > m_sampleListFileIndex;

    // Element(s)
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_fitType;
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_weighting;
    lmx::ct_complex_optional< c_PeakDetectionType > m_peakDetection;
    lmx::ct_complex_multi< c_Filter > m_filter;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_AnalyteSettings();
    LMX_GDECL c_AnalyteSettings( const c_AnalyteSettings & r_rhs );
    LMX_GDECL c_AnalyteSettings & operator = ( const c_AnalyteSettings & r_rhs );
    LMX_GDECL virtual c_AnalyteSettings * clone() const;
    LMX_GDECL void swap( c_AnalyteSettings & r_rhs );
    LMX_GDECL virtual ~c_AnalyteSettings();

    // Attribute(s)

    //    id --> xs:ID[0..1]
    LMX_GDECL const lmx::tlmx_unicode_string & get_id() const { return m_id.get(); }
    LMX_GDECL lmx::elmx_error set_id( const lmx::tlmx_unicode_string & value ) { return m_id.set( value ); }
    LMX_GDECL bool isset_id() const { return m_id.is_value_set(); }
    LMX_GDECL void unset_id() { m_id.unset(); }

    //    scanModeId --> xs:IDREF[0..1]
    LMX_GDECL const lmx::tlmx_unicode_string & get_scanModeId() const { return m_scanModeId.get(); }
    LMX_GDECL lmx::elmx_error set_scanModeId( const lmx::tlmx_unicode_string & value ) { return m_scanModeId.set( value ); }
    LMX_GDECL bool isset_scanModeId() const { return m_scanModeId.is_value_set(); }
    LMX_GDECL void unset_scanModeId() { m_scanModeId.unset(); }

    //    referenceAnalyteId --> xs:IDREF[0..1]
    LMX_GDECL const lmx::tlmx_unicode_string & get_referenceAnalyteId() const { return m_referenceAnalyteId.get(); }
    LMX_GDECL lmx::elmx_error set_referenceAnalyteId( const lmx::tlmx_unicode_string & value ) { return m_referenceAnalyteId.set( value ); }
    LMX_GDECL bool isset_referenceAnalyteId() const { return m_referenceAnalyteId.is_value_set(); }
    LMX_GDECL void unset_referenceAnalyteId() { m_referenceAnalyteId.unset(); }

    //    internalStandardId --> xs:IDREF[0..1]
    LMX_GDECL const lmx::tlmx_unicode_string & get_internalStandardId() const { return m_internalStandardId.get(); }
    LMX_GDECL lmx::elmx_error set_internalStandardId( const lmx::tlmx_unicode_string & value ) { return m_internalStandardId.set( value ); }
    LMX_GDECL bool isset_internalStandardId() const { return m_internalStandardId.is_value_set(); }
    LMX_GDECL void unset_internalStandardId() { m_internalStandardId.unset(); }

    //    sampleListFileIndex --> xs:int{-2147483648<=x<=2147483647}[0..1] (Default: 0)
    LMX_GDECL const lmx::tlmx_int32 & get_sampleListFileIndex() const { return m_sampleListFileIndex.get(); }
    LMX_GDECL lmx::elmx_error set_sampleListFileIndex( const lmx::tlmx_int32 & value );
    LMX_GDECL bool isset_sampleListFileIndex() const { return m_sampleListFileIndex.is_value_set(); }
    LMX_GDECL void unset_sampleListFileIndex();
    // Element(s)

    //    fitType --> xs:string (Default: Linear)
    LMX_GDECL const lmx::tlmx_unicode_string & get_fitType() const { return m_fitType.get(); }
    LMX_GDECL lmx::elmx_error set_fitType( const lmx::tlmx_unicode_string & value );
    enum Method_enum_fitType {
            Method_fitType_unknown,
            Method_fitType__Linear,
            Method_fitType__LinearThruZero,
            Method_fitType__Quadratic,
            Method_fitType__QuadraticThruZero,
            Method_fitType__None };
    LMX_GDECL Method_enum_fitType getenum_fitType() const;
    LMX_GDECL bool setenum_fitType( Method_enum_fitType value );
            // Enum options:
            // AdvionObjects::c_AnalyteSettings::Method_fitType__Linear
            // AdvionObjects::c_AnalyteSettings::Method_fitType__LinearThruZero
            // AdvionObjects::c_AnalyteSettings::Method_fitType__Quadratic
            // AdvionObjects::c_AnalyteSettings::Method_fitType__QuadraticThruZero
            // AdvionObjects::c_AnalyteSettings::Method_fitType__None

    //    weighting --> xs:string (Default: None)
    LMX_GDECL const lmx::tlmx_unicode_string & get_weighting() const { return m_weighting.get(); }
    LMX_GDECL lmx::elmx_error set_weighting( const lmx::tlmx_unicode_string & value );
    enum Method_enum_weighting {
            Method_weighting_unknown,
            Method_weighting__None,
            Method_weighting__Concentration,
            Method_weighting__ConcentrationSquared,
            Method_weighting__Intensity,
            Method_weighting__IntensitySquared,
            Method_weighting__Variance };
    LMX_GDECL Method_enum_weighting getenum_weighting() const;
    LMX_GDECL bool setenum_weighting( Method_enum_weighting value );
            // Enum options:
            // AdvionObjects::c_AnalyteSettings::Method_weighting__None
            // AdvionObjects::c_AnalyteSettings::Method_weighting__Concentration
            // AdvionObjects::c_AnalyteSettings::Method_weighting__ConcentrationSquared
            // AdvionObjects::c_AnalyteSettings::Method_weighting__Intensity
            // AdvionObjects::c_AnalyteSettings::Method_weighting__IntensitySquared
            // AdvionObjects::c_AnalyteSettings::Method_weighting__Variance

    //    peakDetection --> PeakDetectionType[0..1]
    LMX_GDECL const c_PeakDetectionType & get_peakDetection() const { return m_peakDetection.get(); }
    LMX_GDECL c_PeakDetectionType & get_peakDetection() { return m_peakDetection.get(); } // For read/write access
    LMX_GDECL c_PeakDetectionType & assign_peakDetection( const c_PeakDetectionType & value ) { return (get_peakDetection() = value); }
    LMX_GDECL c_PeakDetectionType & assign_peakDetection( c_PeakDetectionType * p ) { return m_peakDetection.assign( p ); }
    LMX_GDECL bool isset_peakDetection() const { return m_peakDetection.is_value_set(); }
    LMX_GDECL void unset_peakDetection() { m_peakDetection.unset(); }

    //    filter --> Filter[0..*]
    LMX_GDECL const c_Filter & get_filter( size_t index ) const { return m_filter.get( index ); }  // For read access
    LMX_GDECL lmx::elmx_error append_filter() { return append_filter( new c_Filter ); }                    // For write access
    LMX_GDECL lmx::elmx_error append_filter( c_Filter * p_value ) // For write access
    {
        lmx::uniq_ptr< c_Filter >::type auto_p_value( p_value );
        m_filter.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_Filter & back_filter() { return m_filter.back(); }                           // For write access
    LMX_GDECL lmx::elmx_error insert_filter( size_t index ) { return insert_filter( index, new c_Filter ); }      // For write access
    LMX_GDECL lmx::elmx_error insert_filter( size_t index, c_Filter * p_value ) // For write access
    {
        lmx::uniq_ptr< c_Filter >::type auto_p_value( p_value );
        m_filter.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_Filter & get_filter( size_t index ) { return m_filter.get( index ); }              // For read/write access
    LMX_GDECL void delete_filter( size_t index )
    {
        lmx_assert( index < m_filter.size() );
        m_filter.erase( index );
    }
    LMX_GDECL void clear_filter() { m_filter.clear(); }
    LMX_GDECL c_Filter & assign_filter( size_t index, const c_Filter & value ) { return get_filter( index ) = value; } // Deep Copy
    LMX_GDECL c_Filter & assign_filter( size_t index, c_Filter * p ) { return m_filter.assign( index, p ); }
    LMX_GDECL size_t size_filter() const { return m_filter.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "AnalyteSettings" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "AnalyteSettings" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: PeakDetection.xsd(3)
class c_peakDetection
{
    //:snippet:start peakDetection
    //:snippet:end peakDetection

private:
    // Attribute(s)
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_version;

    // Element(s)
    lmx::ct_complex_single< c_PeakDetectionType > m_setup;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_peakDetection();
    LMX_GDECL c_peakDetection( const c_peakDetection & r_rhs );
    LMX_GDECL c_peakDetection & operator = ( const c_peakDetection & r_rhs );
    LMX_GDECL virtual c_peakDetection * clone() const;
    LMX_GDECL void swap( c_peakDetection & r_rhs );
    LMX_GDECL c_peakDetection( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    // Convenience constructors
    LMX_GDECL c_peakDetection( const char c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL c_peakDetection( const wchar_t c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL c_peakDetection( const char * p_memory, size_t memory_size, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_peakDetection( const std::string & r_string, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_peakDetection( const lmx::c_any_info & r_any_info, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL virtual ~c_peakDetection();

    // Attribute(s)

    //    version --> xs:string[0..1] (Default: 1.0)
    LMX_GDECL const lmx::tlmx_unicode_string & get_version() const { return m_version.get(); }
    LMX_GDECL lmx::elmx_error set_version( const lmx::tlmx_unicode_string & value ) { return m_version.set( value ); }
    LMX_GDECL bool isset_version() const { return m_version.is_value_set(); }
    LMX_GDECL void unset_version();
    // Element(s)

    //    setup --> PeakDetectionType
    LMX_GDECL const c_PeakDetectionType & get_setup() const { return m_setup.get(); }
    LMX_GDECL c_PeakDetectionType & get_setup() { return m_setup.get(); } // For read/write access
    LMX_GDECL c_PeakDetectionType & assign_setup( const c_PeakDetectionType & value ) { return (get_setup() = value); }
    LMX_GDECL c_PeakDetectionType & assign_setup( c_PeakDetectionType * p ) { return m_setup.assign( p ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const
    {
        LMX_NO_WARN_UNUSED( p_tracker_in );
        return true;
    }

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "peakDetection" ) const;

    LMX_GDECL static const lmx::s_ns_map * ns_map() { return Method_reader; }
    // Convenience marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #if defined( _MSC_VER ) && _MSC_VER >= 1400
        LMX_GDECL lmx::elmx_error marshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #endif
    LMX_GDECL lmx::elmx_error marshal( std::string * p_string, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error marshal( std::ostream & r_sos, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error unmarshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL lmx::elmx_error unmarshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL lmx::elmx_error unmarshal( const char * p_memory, size_t memory_size, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL lmx::elmx_error unmarshal( const std::string & r_string, lmx::s_debug_error * p_debug_error = LMXNULL )
    {
        return unmarshal( r_string.data(), r_string.size(), p_debug_error );
    }
    LMX_GDECL lmx::elmx_error unmarshal( const lmx::c_any_info & r_any_info, lmx::s_debug_error * p_debug_error = LMXNULL );

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "peakDetection" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader );
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: PeakDetection.xsd(12)
class c_GlobalPeakDetection : public c_PeakDetectionType
{
    //:snippet:start GlobalPeakDetection
    //:snippet:end GlobalPeakDetection

private:
    // Element(s)
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_maxWidth;
    lmx::ct_simple_pod_optional< bool > m_excludeNoise;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_sigma;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_threshold;
    lmx::ct_simple_pod_optional< lmx::tlmx_int32 > m_numPeakLabels;
    lmx::ct_simple_pod_optional< bool > m_estimateWidth;
    lmx::ct_complex_multi< c_IntegrationPoint > m_integrationPoint;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_targetRetentionTime;
    lmx::ct_simple_pod_optional< bool > m_userModified;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_GlobalPeakDetection();
    LMX_GDECL c_GlobalPeakDetection( const c_GlobalPeakDetection & r_rhs );
    LMX_GDECL c_GlobalPeakDetection & operator = ( const c_GlobalPeakDetection & r_rhs );
    LMX_GDECL virtual c_GlobalPeakDetection * clone() const;
    LMX_GDECL void swap( c_GlobalPeakDetection & r_rhs );
    LMX_GDECL virtual ~c_GlobalPeakDetection();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_PeakDetectionType::has_id( id_in );
    }

    // Element(s)

    //    maxWidth --> xs:double[0..1] (Default: 40.0)
    LMX_GDECL const lmx::tlmx_double & get_maxWidth() const { return m_maxWidth.get(); }
    LMX_GDECL lmx::elmx_error set_maxWidth( const lmx::tlmx_double & value ) { return m_maxWidth.set( value ); }
    LMX_GDECL bool isset_maxWidth() const { return m_maxWidth.is_value_set(); }
    LMX_GDECL void unset_maxWidth();

    //    excludeNoise --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_excludeNoise() const { return m_excludeNoise.get(); }
    LMX_GDECL lmx::elmx_error set_excludeNoise( const bool & value ) { return m_excludeNoise.set( value ); }
    LMX_GDECL bool isset_excludeNoise() const { return m_excludeNoise.is_value_set(); }
    LMX_GDECL void unset_excludeNoise();

    //    sigma --> xs:double[0..1] (Default: 0.0)
    LMX_GDECL const lmx::tlmx_double & get_sigma() const { return m_sigma.get(); }
    LMX_GDECL lmx::elmx_error set_sigma( const lmx::tlmx_double & value ) { return m_sigma.set( value ); }
    LMX_GDECL bool isset_sigma() const { return m_sigma.is_value_set(); }
    LMX_GDECL void unset_sigma();

    //    threshold --> xs:double[0..1]
    LMX_GDECL const lmx::tlmx_double & get_threshold() const { return m_threshold.get(); }
    LMX_GDECL lmx::elmx_error set_threshold( const lmx::tlmx_double & value ) { return m_threshold.set( value ); }
    LMX_GDECL bool isset_threshold() const { return m_threshold.is_value_set(); }
    LMX_GDECL void unset_threshold() { m_threshold.unset(); }

    //    numPeakLabels --> xs:int{-2147483648<=x<=2147483647}[0..1] (Default: 10)
    LMX_GDECL const lmx::tlmx_int32 & get_numPeakLabels() const { return m_numPeakLabels.get(); }
    LMX_GDECL lmx::elmx_error set_numPeakLabels( const lmx::tlmx_int32 & value );
    LMX_GDECL bool isset_numPeakLabels() const { return m_numPeakLabels.is_value_set(); }
    LMX_GDECL void unset_numPeakLabels();

    //    estimateWidth --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_estimateWidth() const { return m_estimateWidth.get(); }
    LMX_GDECL lmx::elmx_error set_estimateWidth( const bool & value ) { return m_estimateWidth.set( value ); }
    LMX_GDECL bool isset_estimateWidth() const { return m_estimateWidth.is_value_set(); }
    LMX_GDECL void unset_estimateWidth();

    //    integrationPoint --> IntegrationPoint[0..*]
    LMX_GDECL const c_IntegrationPoint & get_integrationPoint( size_t index ) const { return m_integrationPoint.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_integrationPoint() { return append_integrationPoint( new c_IntegrationPoint ); }          // For write access
    LMX_GDECL lmx::elmx_error append_integrationPoint( c_IntegrationPoint * p_value ) // For write access
    {
        lmx::uniq_ptr< c_IntegrationPoint >::type auto_p_value( p_value );
        m_integrationPoint.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_IntegrationPoint & back_integrationPoint() { return m_integrationPoint.back(); }       // For write access
    LMX_GDECL lmx::elmx_error insert_integrationPoint( size_t index ) { return insert_integrationPoint( index, new c_IntegrationPoint ); } // For write access
    LMX_GDECL lmx::elmx_error insert_integrationPoint( size_t index, c_IntegrationPoint * p_value ) // For write access
    {
        lmx::uniq_ptr< c_IntegrationPoint >::type auto_p_value( p_value );
        m_integrationPoint.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_IntegrationPoint & get_integrationPoint( size_t index ) { return m_integrationPoint.get( index ); } // For read/write access
    LMX_GDECL void delete_integrationPoint( size_t index )
    {
        lmx_assert( index < m_integrationPoint.size() );
        m_integrationPoint.erase( index );
    }
    LMX_GDECL void clear_integrationPoint() { m_integrationPoint.clear(); }
    LMX_GDECL c_IntegrationPoint & assign_integrationPoint( size_t index, const c_IntegrationPoint & value ) { return get_integrationPoint( index ) = value; } // Deep Copy
    LMX_GDECL c_IntegrationPoint & assign_integrationPoint( size_t index, c_IntegrationPoint * p ) { return m_integrationPoint.assign( index, p ); }
    LMX_GDECL size_t size_integrationPoint() const { return m_integrationPoint.size(); }

    //    targetRetentionTime --> xs:double[0..1]
    LMX_GDECL const lmx::tlmx_double & get_targetRetentionTime() const { return m_targetRetentionTime.get(); }
    LMX_GDECL lmx::elmx_error set_targetRetentionTime( const lmx::tlmx_double & value ) { return m_targetRetentionTime.set( value ); }
    LMX_GDECL bool isset_targetRetentionTime() const { return m_targetRetentionTime.is_value_set(); }
    LMX_GDECL void unset_targetRetentionTime() { m_targetRetentionTime.unset(); }

    //    userModified --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_userModified() const { return m_userModified.get(); }
    LMX_GDECL lmx::elmx_error set_userModified( const bool & value ) { return m_userModified.set( value ); }
    LMX_GDECL bool isset_userModified() const { return m_userModified.is_value_set(); }
    LMX_GDECL void unset_userModified();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "GlobalPeakDetection" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "GlobalPeakDetection" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: ProcessMethod.xsd(16)
class c_BackgroundOptions
{
    //:snippet:start BackgroundOptions
    //:snippet:end BackgroundOptions

private:
    // Element(s)
    lmx::ct_simple_pod_optional< bool > m_enableMultiple;
    lmx::ct_simple_pod_optional< bool > m_removeFromSpectra;
    lmx::ct_simple_pod_optional< bool > m_removeFromChromatograms;
    lmx::ct_complex_multi< c_BackgroundSpectrum > m_backgroundSpectra;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_BackgroundOptions();
    LMX_GDECL c_BackgroundOptions( const c_BackgroundOptions & r_rhs );
    LMX_GDECL c_BackgroundOptions & operator = ( const c_BackgroundOptions & r_rhs );
    LMX_GDECL virtual c_BackgroundOptions * clone() const;
    LMX_GDECL void swap( c_BackgroundOptions & r_rhs );
    LMX_GDECL virtual ~c_BackgroundOptions();

    // Element(s)

    //    enableMultiple --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_enableMultiple() const { return m_enableMultiple.get(); }
    LMX_GDECL lmx::elmx_error set_enableMultiple( const bool & value ) { return m_enableMultiple.set( value ); }
    LMX_GDECL bool isset_enableMultiple() const { return m_enableMultiple.is_value_set(); }
    LMX_GDECL void unset_enableMultiple();

    //    removeFromSpectra --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_removeFromSpectra() const { return m_removeFromSpectra.get(); }
    LMX_GDECL lmx::elmx_error set_removeFromSpectra( const bool & value ) { return m_removeFromSpectra.set( value ); }
    LMX_GDECL bool isset_removeFromSpectra() const { return m_removeFromSpectra.is_value_set(); }
    LMX_GDECL void unset_removeFromSpectra();

    //    removeFromChromatograms --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_removeFromChromatograms() const { return m_removeFromChromatograms.get(); }
    LMX_GDECL lmx::elmx_error set_removeFromChromatograms( const bool & value ) { return m_removeFromChromatograms.set( value ); }
    LMX_GDECL bool isset_removeFromChromatograms() const { return m_removeFromChromatograms.is_value_set(); }
    LMX_GDECL void unset_removeFromChromatograms();

    //    backgroundSpectra --> BackgroundSpectrum[0..*]
    LMX_GDECL const c_BackgroundSpectrum & get_backgroundSpectra( size_t index ) const { return m_backgroundSpectra.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_backgroundSpectra() { return append_backgroundSpectra( new c_BackgroundSpectrum ); }         // For write access
    LMX_GDECL lmx::elmx_error append_backgroundSpectra( c_BackgroundSpectrum * p_value ) // For write access
    {
        lmx::uniq_ptr< c_BackgroundSpectrum >::type auto_p_value( p_value );
        m_backgroundSpectra.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_BackgroundSpectrum & back_backgroundSpectra() { return m_backgroundSpectra.back(); }    // For write access
    LMX_GDECL lmx::elmx_error insert_backgroundSpectra( size_t index ) { return insert_backgroundSpectra( index, new c_BackgroundSpectrum ); } // For write access
    LMX_GDECL lmx::elmx_error insert_backgroundSpectra( size_t index, c_BackgroundSpectrum * p_value ) // For write access
    {
        lmx::uniq_ptr< c_BackgroundSpectrum >::type auto_p_value( p_value );
        m_backgroundSpectra.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_BackgroundSpectrum & get_backgroundSpectra( size_t index ) { return m_backgroundSpectra.get( index ); } // For read/write access
    LMX_GDECL void delete_backgroundSpectra( size_t index )
    {
        lmx_assert( index < m_backgroundSpectra.size() );
        m_backgroundSpectra.erase( index );
    }
    LMX_GDECL void clear_backgroundSpectra() { m_backgroundSpectra.clear(); }
    LMX_GDECL c_BackgroundSpectrum & assign_backgroundSpectra( size_t index, const c_BackgroundSpectrum & value ) { return get_backgroundSpectra( index ) = value; } // Deep Copy
    LMX_GDECL c_BackgroundSpectrum & assign_backgroundSpectra( size_t index, c_BackgroundSpectrum * p ) { return m_backgroundSpectra.assign( index, p ); }
    LMX_GDECL size_t size_backgroundSpectra() const { return m_backgroundSpectra.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const
    {
        LMX_NO_WARN_UNUSED( p_tracker_in );
        return true;
    }

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "BackgroundOptions" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "BackgroundOptions" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

class c_SpectrumGraphInfo;
class c_XICChromGraphInfo;
class c_ScalarChannelChromGraphInfo;
class c_BasePeakChromGraphInfo;
class c_TICChromGraphInfo;
class c_ParentChromGraphInfo;
class c_BackgroundSpectrumGraphInfo;

// From: ProcessMethod.xsd(30)
class c_GraphInfo
{
    //:snippet:start GraphInfo
    //:snippet:end GraphInfo

private:
    // Element(s)
    lmx::ct_simple_pod_optional< bool > m_isStacked;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_startX;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_endX;
    lmx::ct_complex_multi< c_BackgroundSpectrum > m_backgroundSpectrum;
    lmx::ct_complex_optional< c_Filter > m_currentFilter;
    lmx::ct_complex_multi< c_Filter > m_appliedFilters;
    lmx::ct_complex_multi< c_PeakDetectionType > m_peakDetections;
    lmx::ct_simple_pod_optional< bool > m_delta;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_GraphInfo();
    LMX_GDECL c_GraphInfo( const c_GraphInfo & r_rhs );
    LMX_GDECL c_GraphInfo & operator = ( const c_GraphInfo & r_rhs );
    LMX_GDECL virtual c_GraphInfo * clone() const;
    LMX_GDECL void swap( c_GraphInfo & r_rhs );
    LMX_GDECL virtual ~c_GraphInfo();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id;
    }

    LMX_GDECL static c_GraphInfo * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    //    isStacked --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_isStacked() const { return m_isStacked.get(); }
    LMX_GDECL lmx::elmx_error set_isStacked( const bool & value ) { return m_isStacked.set( value ); }
    LMX_GDECL bool isset_isStacked() const { return m_isStacked.is_value_set(); }
    LMX_GDECL void unset_isStacked();

    //    startX --> xs:double[0..1] (Default: 0.0)
    LMX_GDECL const lmx::tlmx_double & get_startX() const { return m_startX.get(); }
    LMX_GDECL lmx::elmx_error set_startX( const lmx::tlmx_double & value ) { return m_startX.set( value ); }
    LMX_GDECL bool isset_startX() const { return m_startX.is_value_set(); }
    LMX_GDECL void unset_startX();

    //    endX --> xs:double[0..1] (Default: 1000000000.0)
    LMX_GDECL const lmx::tlmx_double & get_endX() const { return m_endX.get(); }
    LMX_GDECL lmx::elmx_error set_endX( const lmx::tlmx_double & value ) { return m_endX.set( value ); }
    LMX_GDECL bool isset_endX() const { return m_endX.is_value_set(); }
    LMX_GDECL void unset_endX();

    //    backgroundSpectrum --> BackgroundSpectrum[0..*]
    LMX_GDECL const c_BackgroundSpectrum & get_backgroundSpectrum( size_t index ) const { return m_backgroundSpectrum.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_backgroundSpectrum() { return append_backgroundSpectrum( new c_BackgroundSpectrum ); }        // For write access
    LMX_GDECL lmx::elmx_error append_backgroundSpectrum( c_BackgroundSpectrum * p_value ) // For write access
    {
        lmx::uniq_ptr< c_BackgroundSpectrum >::type auto_p_value( p_value );
        m_backgroundSpectrum.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_BackgroundSpectrum & back_backgroundSpectrum() { return m_backgroundSpectrum.back(); }   // For write access
    LMX_GDECL lmx::elmx_error insert_backgroundSpectrum( size_t index ) { return insert_backgroundSpectrum( index, new c_BackgroundSpectrum ); } // For write access
    LMX_GDECL lmx::elmx_error insert_backgroundSpectrum( size_t index, c_BackgroundSpectrum * p_value ) // For write access
    {
        lmx::uniq_ptr< c_BackgroundSpectrum >::type auto_p_value( p_value );
        m_backgroundSpectrum.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_BackgroundSpectrum & get_backgroundSpectrum( size_t index ) { return m_backgroundSpectrum.get( index ); } // For read/write access
    LMX_GDECL void delete_backgroundSpectrum( size_t index )
    {
        lmx_assert( index < m_backgroundSpectrum.size() );
        m_backgroundSpectrum.erase( index );
    }
    LMX_GDECL void clear_backgroundSpectrum() { m_backgroundSpectrum.clear(); }
    LMX_GDECL c_BackgroundSpectrum & assign_backgroundSpectrum( size_t index, const c_BackgroundSpectrum & value ) { return get_backgroundSpectrum( index ) = value; } // Deep Copy
    LMX_GDECL c_BackgroundSpectrum & assign_backgroundSpectrum( size_t index, c_BackgroundSpectrum * p ) { return m_backgroundSpectrum.assign( index, p ); }
    LMX_GDECL size_t size_backgroundSpectrum() const { return m_backgroundSpectrum.size(); }

    //    currentFilter --> Filter[0..1]
    LMX_GDECL const c_Filter & get_currentFilter() const { return m_currentFilter.get(); }
    LMX_GDECL c_Filter & get_currentFilter() { return m_currentFilter.get(); } // For read/write access
    LMX_GDECL c_Filter & assign_currentFilter( const c_Filter & value ) { return (get_currentFilter() = value); }
    LMX_GDECL c_Filter & assign_currentFilter( c_Filter * p ) { return m_currentFilter.assign( p ); }
    LMX_GDECL bool isset_currentFilter() const { return m_currentFilter.is_value_set(); }
    LMX_GDECL void unset_currentFilter() { m_currentFilter.unset(); }

    //    appliedFilters --> Filter[0..*]
    LMX_GDECL const c_Filter & get_appliedFilters( size_t index ) const { return m_appliedFilters.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_appliedFilters() { return append_appliedFilters( new c_Filter ); }            // For write access
    LMX_GDECL lmx::elmx_error append_appliedFilters( c_Filter * p_value ) // For write access
    {
        lmx::uniq_ptr< c_Filter >::type auto_p_value( p_value );
        m_appliedFilters.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_Filter & back_appliedFilters() { return m_appliedFilters.back(); }                   // For write access
    LMX_GDECL lmx::elmx_error insert_appliedFilters( size_t index ) { return insert_appliedFilters( index, new c_Filter ); } // For write access
    LMX_GDECL lmx::elmx_error insert_appliedFilters( size_t index, c_Filter * p_value ) // For write access
    {
        lmx::uniq_ptr< c_Filter >::type auto_p_value( p_value );
        m_appliedFilters.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_Filter & get_appliedFilters( size_t index ) { return m_appliedFilters.get( index ); }      // For read/write access
    LMX_GDECL void delete_appliedFilters( size_t index )
    {
        lmx_assert( index < m_appliedFilters.size() );
        m_appliedFilters.erase( index );
    }
    LMX_GDECL void clear_appliedFilters() { m_appliedFilters.clear(); }
    LMX_GDECL c_Filter & assign_appliedFilters( size_t index, const c_Filter & value ) { return get_appliedFilters( index ) = value; } // Deep Copy
    LMX_GDECL c_Filter & assign_appliedFilters( size_t index, c_Filter * p ) { return m_appliedFilters.assign( index, p ); }
    LMX_GDECL size_t size_appliedFilters() const { return m_appliedFilters.size(); }

    //    peakDetections --> PeakDetectionType[0..*]
    LMX_GDECL const c_PeakDetectionType & get_peakDetections( size_t index ) const { return m_peakDetections.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_peakDetections() { return append_peakDetections( new c_PeakDetectionType ); }            // For write access
    LMX_GDECL lmx::elmx_error append_peakDetections( c_PeakDetectionType * p_value ) // For write access
    {
        lmx::uniq_ptr< c_PeakDetectionType >::type auto_p_value( p_value );
        m_peakDetections.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_PeakDetectionType & back_peakDetections() { return m_peakDetections.back(); }        // For write access
    LMX_GDECL lmx::elmx_error insert_peakDetections( size_t index ) { return insert_peakDetections( index, new c_PeakDetectionType ); } // For write access
    LMX_GDECL lmx::elmx_error insert_peakDetections( size_t index, c_PeakDetectionType * p_value ) // For write access
    {
        lmx::uniq_ptr< c_PeakDetectionType >::type auto_p_value( p_value );
        m_peakDetections.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_PeakDetectionType & get_peakDetections( size_t index ) { return m_peakDetections.get( index ); } // For read/write access
    LMX_GDECL void delete_peakDetections( size_t index )
    {
        lmx_assert( index < m_peakDetections.size() );
        m_peakDetections.erase( index );
    }
    LMX_GDECL void clear_peakDetections() { m_peakDetections.clear(); }
    LMX_GDECL c_PeakDetectionType & assign_peakDetections( size_t index, const c_PeakDetectionType & value ) { return get_peakDetections( index ) = value; } // Deep Copy
    LMX_GDECL c_PeakDetectionType & assign_peakDetections( size_t index, c_PeakDetectionType * p ) { return m_peakDetections.assign( index, p ); }
    LMX_GDECL size_t size_peakDetections() const { return m_peakDetections.size(); }

    //    delta --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_delta() const { return m_delta.get(); }
    LMX_GDECL lmx::elmx_error set_delta( const bool & value ) { return m_delta.set( value ); }
    LMX_GDECL bool isset_delta() const { return m_delta.is_value_set(); }
    LMX_GDECL void unset_delta();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const
    {
        LMX_NO_WARN_UNUSED( p_tracker_in );
        return true;
    }

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "GraphInfo" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "GraphInfo" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

class c_BackgroundSpectrumGraphInfo;

// From: ProcessMethod.xsd(42)
class c_SpectrumGraphInfo : public c_GraphInfo
{
    //:snippet:start SpectrumGraphInfo
    //:snippet:end SpectrumGraphInfo

private:
    // Element(s)
    lmx::ct_simple_pod_optional< bool > m_isStick;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_startRetentionTime;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_endRetentionTime;
    lmx::ct_simple_pod_optional< bool > m_isFullRetentionTime;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_SpectrumGraphInfo();
    LMX_GDECL c_SpectrumGraphInfo( const c_SpectrumGraphInfo & r_rhs );
    LMX_GDECL c_SpectrumGraphInfo & operator = ( const c_SpectrumGraphInfo & r_rhs );
    LMX_GDECL virtual c_SpectrumGraphInfo * clone() const;
    LMX_GDECL void swap( c_SpectrumGraphInfo & r_rhs );
    LMX_GDECL virtual ~c_SpectrumGraphInfo();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_GraphInfo::has_id( id_in );
    }

    LMX_GDECL static c_SpectrumGraphInfo * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    //    isStick --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_isStick() const { return m_isStick.get(); }
    LMX_GDECL lmx::elmx_error set_isStick( const bool & value ) { return m_isStick.set( value ); }
    LMX_GDECL bool isset_isStick() const { return m_isStick.is_value_set(); }
    LMX_GDECL void unset_isStick();

    //    startRetentionTime --> xs:double[0..1] (Default: 0.0)
    LMX_GDECL const lmx::tlmx_double & get_startRetentionTime() const { return m_startRetentionTime.get(); }
    LMX_GDECL lmx::elmx_error set_startRetentionTime( const lmx::tlmx_double & value ) { return m_startRetentionTime.set( value ); }
    LMX_GDECL bool isset_startRetentionTime() const { return m_startRetentionTime.is_value_set(); }
    LMX_GDECL void unset_startRetentionTime();

    //    endRetentionTime --> xs:double[0..1] (Default: 1000000000.0)
    LMX_GDECL const lmx::tlmx_double & get_endRetentionTime() const { return m_endRetentionTime.get(); }
    LMX_GDECL lmx::elmx_error set_endRetentionTime( const lmx::tlmx_double & value ) { return m_endRetentionTime.set( value ); }
    LMX_GDECL bool isset_endRetentionTime() const { return m_endRetentionTime.is_value_set(); }
    LMX_GDECL void unset_endRetentionTime();

    //    isFullRetentionTime --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_isFullRetentionTime() const { return m_isFullRetentionTime.get(); }
    LMX_GDECL lmx::elmx_error set_isFullRetentionTime( const bool & value ) { return m_isFullRetentionTime.set( value ); }
    LMX_GDECL bool isset_isFullRetentionTime() const { return m_isFullRetentionTime.is_value_set(); }
    LMX_GDECL void unset_isFullRetentionTime();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "SpectrumGraphInfo" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "SpectrumGraphInfo" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: ProcessMethod.xsd(54)
class c_BackgroundSpectrumGraphInfo : public c_SpectrumGraphInfo
{
    //:snippet:start BackgroundSpectrumGraphInfo
    //:snippet:end BackgroundSpectrumGraphInfo

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_BackgroundSpectrumGraphInfo();
    LMX_GDECL c_BackgroundSpectrumGraphInfo( const c_BackgroundSpectrumGraphInfo & r_rhs );
    LMX_GDECL c_BackgroundSpectrumGraphInfo & operator = ( const c_BackgroundSpectrumGraphInfo & r_rhs );
    LMX_GDECL virtual c_BackgroundSpectrumGraphInfo * clone() const;
    LMX_GDECL void swap( c_BackgroundSpectrumGraphInfo & r_rhs );
    LMX_GDECL virtual ~c_BackgroundSpectrumGraphInfo();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_SpectrumGraphInfo::has_id( id_in );
    }

    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "BackgroundSpectrumGraphInfo" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "BackgroundSpectrumGraphInfo" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

class c_XICChromGraphInfo;
class c_ScalarChannelChromGraphInfo;
class c_BasePeakChromGraphInfo;
class c_TICChromGraphInfo;
class c_ParentChromGraphInfo;

// From: ProcessMethod.xsd(59)
class c_ChromGraphInfo : public c_GraphInfo
{
    //:snippet:start ChromGraphInfo
    //:snippet:end ChromGraphInfo

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ChromGraphInfo();
    LMX_GDECL c_ChromGraphInfo( const c_ChromGraphInfo & r_rhs );
    LMX_GDECL c_ChromGraphInfo & operator = ( const c_ChromGraphInfo & r_rhs );
    LMX_GDECL virtual c_ChromGraphInfo * clone() const;
    LMX_GDECL void swap( c_ChromGraphInfo & r_rhs );
    LMX_GDECL virtual ~c_ChromGraphInfo();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_GraphInfo::has_id( id_in );
    }

    LMX_GDECL static c_ChromGraphInfo * factory( int ns_id, const std::string & r_local_name );
    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ChromGraphInfo" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ChromGraphInfo" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: ProcessMethod.xsd(64)
class c_ParentChromGraphInfo : public c_ChromGraphInfo
{
    //:snippet:start ParentChromGraphInfo
    //:snippet:end ParentChromGraphInfo

private:
    // Element(s)
    lmx::ct_simple_pod_optional< bool > m_isFullRetentionTime;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ParentChromGraphInfo();
    LMX_GDECL c_ParentChromGraphInfo( const c_ParentChromGraphInfo & r_rhs );
    LMX_GDECL c_ParentChromGraphInfo & operator = ( const c_ParentChromGraphInfo & r_rhs );
    LMX_GDECL virtual c_ParentChromGraphInfo * clone() const;
    LMX_GDECL void swap( c_ParentChromGraphInfo & r_rhs );
    LMX_GDECL virtual ~c_ParentChromGraphInfo();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ChromGraphInfo::has_id( id_in );
    }

    // Element(s)

    //    isFullRetentionTime --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_isFullRetentionTime() const { return m_isFullRetentionTime.get(); }
    LMX_GDECL lmx::elmx_error set_isFullRetentionTime( const bool & value ) { return m_isFullRetentionTime.set( value ); }
    LMX_GDECL bool isset_isFullRetentionTime() const { return m_isFullRetentionTime.is_value_set(); }
    LMX_GDECL void unset_isFullRetentionTime();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ParentChromGraphInfo" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ParentChromGraphInfo" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: ProcessMethod.xsd(73)
class c_TICChromGraphInfo : public c_ChromGraphInfo
{
    //:snippet:start TICChromGraphInfo
    //:snippet:end TICChromGraphInfo

private:
    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_TICChromGraphInfo();
    LMX_GDECL c_TICChromGraphInfo( const c_TICChromGraphInfo & r_rhs );
    LMX_GDECL c_TICChromGraphInfo & operator = ( const c_TICChromGraphInfo & r_rhs );
    LMX_GDECL virtual c_TICChromGraphInfo * clone() const;
    LMX_GDECL void swap( c_TICChromGraphInfo & r_rhs );
    LMX_GDECL virtual ~c_TICChromGraphInfo();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ChromGraphInfo::has_id( id_in );
    }

    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "TICChromGraphInfo" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "TICChromGraphInfo" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: ProcessMethod.xsd(78)
class c_XICChromGraphInfo : public c_ChromGraphInfo
{
    //:snippet:start XICChromGraphInfo
    //:snippet:end XICChromGraphInfo

private:
    // Element(s)
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_startMass;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_endMass;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_XICChromGraphInfo();
    LMX_GDECL c_XICChromGraphInfo( const c_XICChromGraphInfo & r_rhs );
    LMX_GDECL c_XICChromGraphInfo & operator = ( const c_XICChromGraphInfo & r_rhs );
    LMX_GDECL virtual c_XICChromGraphInfo * clone() const;
    LMX_GDECL void swap( c_XICChromGraphInfo & r_rhs );
    LMX_GDECL virtual ~c_XICChromGraphInfo();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ChromGraphInfo::has_id( id_in );
    }

    // Element(s)

    //    startMass --> xs:double[0..1] (Default: 0.0)
    LMX_GDECL const lmx::tlmx_double & get_startMass() const { return m_startMass.get(); }
    LMX_GDECL lmx::elmx_error set_startMass( const lmx::tlmx_double & value ) { return m_startMass.set( value ); }
    LMX_GDECL bool isset_startMass() const { return m_startMass.is_value_set(); }
    LMX_GDECL void unset_startMass();

    //    endMass --> xs:double[0..1] (Default: 1000000000.0)
    LMX_GDECL const lmx::tlmx_double & get_endMass() const { return m_endMass.get(); }
    LMX_GDECL lmx::elmx_error set_endMass( const lmx::tlmx_double & value ) { return m_endMass.set( value ); }
    LMX_GDECL bool isset_endMass() const { return m_endMass.is_value_set(); }
    LMX_GDECL void unset_endMass();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "XICChromGraphInfo" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "XICChromGraphInfo" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: ProcessMethod.xsd(88)
class c_BasePeakChromGraphInfo : public c_ChromGraphInfo
{
    //:snippet:start BasePeakChromGraphInfo
    //:snippet:end BasePeakChromGraphInfo

private:
    // Element(s)
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_startMass;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_endMass;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_BasePeakChromGraphInfo();
    LMX_GDECL c_BasePeakChromGraphInfo( const c_BasePeakChromGraphInfo & r_rhs );
    LMX_GDECL c_BasePeakChromGraphInfo & operator = ( const c_BasePeakChromGraphInfo & r_rhs );
    LMX_GDECL virtual c_BasePeakChromGraphInfo * clone() const;
    LMX_GDECL void swap( c_BasePeakChromGraphInfo & r_rhs );
    LMX_GDECL virtual ~c_BasePeakChromGraphInfo();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ChromGraphInfo::has_id( id_in );
    }

    // Element(s)

    //    startMass --> xs:double[0..1] (Default: 0.0)
    LMX_GDECL const lmx::tlmx_double & get_startMass() const { return m_startMass.get(); }
    LMX_GDECL lmx::elmx_error set_startMass( const lmx::tlmx_double & value ) { return m_startMass.set( value ); }
    LMX_GDECL bool isset_startMass() const { return m_startMass.is_value_set(); }
    LMX_GDECL void unset_startMass();

    //    endMass --> xs:double[0..1] (Default: 1000000000.0)
    LMX_GDECL const lmx::tlmx_double & get_endMass() const { return m_endMass.get(); }
    LMX_GDECL lmx::elmx_error set_endMass( const lmx::tlmx_double & value ) { return m_endMass.set( value ); }
    LMX_GDECL bool isset_endMass() const { return m_endMass.is_value_set(); }
    LMX_GDECL void unset_endMass();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "BasePeakChromGraphInfo" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "BasePeakChromGraphInfo" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: ProcessMethod.xsd(98)
class c_ScalarChannelChromGraphInfo : public c_ChromGraphInfo
{
    //:snippet:start ScalarChannelChromGraphInfo
    //:snippet:end ScalarChannelChromGraphInfo

private:
    // Element(s)
    lmx::ct_simple_pod_optional< lmx::tlmx_uns32 > m_index;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ScalarChannelChromGraphInfo();
    LMX_GDECL c_ScalarChannelChromGraphInfo( const c_ScalarChannelChromGraphInfo & r_rhs );
    LMX_GDECL c_ScalarChannelChromGraphInfo & operator = ( const c_ScalarChannelChromGraphInfo & r_rhs );
    LMX_GDECL virtual c_ScalarChannelChromGraphInfo * clone() const;
    LMX_GDECL void swap( c_ScalarChannelChromGraphInfo & r_rhs );
    LMX_GDECL virtual ~c_ScalarChannelChromGraphInfo();

    LMX_GDECL static const lmx::t_class_identity id;
    LMX_GDECL virtual lmx::t_class_identity getid() const { return id; }
    LMX_GDECL virtual bool has_id( lmx::t_class_identity id_in ) const
    {
        return id_in == id || c_ChromGraphInfo::has_id( id_in );
    }

    // Element(s)

    //    index --> xs:int{0<=x<=2147483647}[0..1] (Default: 0)
    LMX_GDECL const lmx::tlmx_uns32 & get_index() const { return m_index.get(); }
    LMX_GDECL lmx::elmx_error set_index( const lmx::tlmx_uns32 & value );
    LMX_GDECL bool isset_index() const { return m_index.is_value_set(); }
    LMX_GDECL void unset_index();

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ScalarChannelChromGraphInfo" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL virtual lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ScalarChannelChromGraphInfo" ) const;
    LMX_GDECL virtual lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(210)
class c_AnalogOutputs
{
    //:snippet:start AnalogOutputs
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end AnalogOutputs

private:
    // Element(s)
    lmx::ct_complex_multi< c_AnalogOutput > m_output;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_AnalogOutputs();
    LMX_GDECL c_AnalogOutputs( const c_AnalogOutputs & r_rhs );
    LMX_GDECL c_AnalogOutputs & operator = ( const c_AnalogOutputs & r_rhs );
    LMX_GDECL virtual c_AnalogOutputs * clone() const;
    LMX_GDECL void swap( c_AnalogOutputs & r_rhs );
    LMX_GDECL virtual ~c_AnalogOutputs();

    // Element(s)

    //    output --> AnalogOutput[4]
    LMX_GDECL const c_AnalogOutput & get_output( size_t index ) const { return m_output.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_output() { return append_output( new c_AnalogOutput ); }                    // For write access
    LMX_GDECL lmx::elmx_error append_output( c_AnalogOutput * p_value ); // For write access
    LMX_GDECL c_AnalogOutput & back_output() { return m_output.back(); }                     // For write access
    LMX_GDECL lmx::elmx_error insert_output( size_t index ) { return insert_output( index, new c_AnalogOutput ); }      // For write access
    LMX_GDECL lmx::elmx_error insert_output( size_t index, c_AnalogOutput * p_value ); // For write access
    LMX_GDECL c_AnalogOutput & get_output( size_t index )    // For read/write access
    {
        lmx_assert( index < 4 );
        return m_output.get( index );
    }
    LMX_GDECL void delete_output( size_t index )
    {
        lmx_assert( index < m_output.size() );
        m_output.erase( index );
    }
    LMX_GDECL void clear_output() { m_output.clear(); }
    LMX_GDECL c_AnalogOutput & assign_output( size_t index, const c_AnalogOutput & value ) { return get_output( index ) = value; } // Deep Copy
    LMX_GDECL c_AnalogOutput & assign_output( size_t index, c_AnalogOutput * p ) { return m_output.assign( index, p ); }
    LMX_GDECL size_t size_output() const { return m_output.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "AnalogOutputs" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "AnalogOutputs" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(334)
class c_ContactClosuresOut
{
    //:snippet:start ContactClosuresOut
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end ContactClosuresOut

private:
    // Element(s)
    lmx::ct_complex_multi< c_ContactClosureOut > m_contactClosure;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_ContactClosuresOut();
    LMX_GDECL c_ContactClosuresOut( const c_ContactClosuresOut & r_rhs );
    LMX_GDECL c_ContactClosuresOut & operator = ( const c_ContactClosuresOut & r_rhs );
    LMX_GDECL virtual c_ContactClosuresOut * clone() const;
    LMX_GDECL void swap( c_ContactClosuresOut & r_rhs );
    LMX_GDECL virtual ~c_ContactClosuresOut();

    // Element(s)

    //    contactClosure --> ContactClosureOut[4]
    LMX_GDECL const c_ContactClosureOut & get_contactClosure( size_t index ) const { return m_contactClosure.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_contactClosure() { return append_contactClosure( new c_ContactClosureOut ); }            // For write access
    LMX_GDECL lmx::elmx_error append_contactClosure( c_ContactClosureOut * p_value ); // For write access
    LMX_GDECL c_ContactClosureOut & back_contactClosure() { return m_contactClosure.back(); }        // For write access
    LMX_GDECL lmx::elmx_error insert_contactClosure( size_t index ) { return insert_contactClosure( index, new c_ContactClosureOut ); } // For write access
    LMX_GDECL lmx::elmx_error insert_contactClosure( size_t index, c_ContactClosureOut * p_value ); // For write access
    LMX_GDECL c_ContactClosureOut & get_contactClosure( size_t index ) // For read/write access
    {
        lmx_assert( index < 4 );
        return m_contactClosure.get( index );
    }
    LMX_GDECL void delete_contactClosure( size_t index )
    {
        lmx_assert( index < m_contactClosure.size() );
        m_contactClosure.erase( index );
    }
    LMX_GDECL void clear_contactClosure() { m_contactClosure.clear(); }
    LMX_GDECL c_ContactClosureOut & assign_contactClosure( size_t index, const c_ContactClosureOut & value ) { return get_contactClosure( index ) = value; } // Deep Copy
    LMX_GDECL c_ContactClosureOut & assign_contactClosure( size_t index, c_ContactClosureOut * p ) { return m_contactClosure.assign( index, p ); }
    LMX_GDECL size_t size_contactClosure() const { return m_contactClosure.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "ContactClosuresOut" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "ContactClosuresOut" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Quantitation.xsd(98)
class c_SemiQuantSettings
{
    //:snippet:start SemiQuantSettings
    //:snippet:end SemiQuantSettings

private:
    // Element(s)
    lmx::ct_simple_pod_optional< bool > m_useDefaultStandards;
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_concentrationUnits;
    lmx::ct_complex_multi< c_SemiQuantStandard > m_defaultStandard;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_SemiQuantSettings();
    LMX_GDECL c_SemiQuantSettings( const c_SemiQuantSettings & r_rhs );
    LMX_GDECL c_SemiQuantSettings & operator = ( const c_SemiQuantSettings & r_rhs );
    LMX_GDECL virtual c_SemiQuantSettings * clone() const;
    LMX_GDECL void swap( c_SemiQuantSettings & r_rhs );
    LMX_GDECL virtual ~c_SemiQuantSettings();

    // Element(s)

    //    useDefaultStandards --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_useDefaultStandards() const { return m_useDefaultStandards.get(); }
    LMX_GDECL lmx::elmx_error set_useDefaultStandards( const bool & value ) { return m_useDefaultStandards.set( value ); }
    LMX_GDECL bool isset_useDefaultStandards() const { return m_useDefaultStandards.is_value_set(); }
    LMX_GDECL void unset_useDefaultStandards();

    //    concentrationUnits --> xs:string (Default: ppb)
    LMX_GDECL const lmx::tlmx_unicode_string & get_concentrationUnits() const { return m_concentrationUnits.get(); }
    LMX_GDECL lmx::elmx_error set_concentrationUnits( const lmx::tlmx_unicode_string & value ) { return m_concentrationUnits.set( value ); }

    //    defaultStandard --> SemiQuantStandard[0..*]
    LMX_GDECL const c_SemiQuantStandard & get_defaultStandard( size_t index ) const { return m_defaultStandard.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_defaultStandard() { return append_defaultStandard( new c_SemiQuantStandard ); }           // For write access
    LMX_GDECL lmx::elmx_error append_defaultStandard( c_SemiQuantStandard * p_value ) // For write access
    {
        lmx::uniq_ptr< c_SemiQuantStandard >::type auto_p_value( p_value );
        m_defaultStandard.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_SemiQuantStandard & back_defaultStandard() { return m_defaultStandard.back(); }       // For write access
    LMX_GDECL lmx::elmx_error insert_defaultStandard( size_t index ) { return insert_defaultStandard( index, new c_SemiQuantStandard ); } // For write access
    LMX_GDECL lmx::elmx_error insert_defaultStandard( size_t index, c_SemiQuantStandard * p_value ) // For write access
    {
        lmx::uniq_ptr< c_SemiQuantStandard >::type auto_p_value( p_value );
        m_defaultStandard.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_SemiQuantStandard & get_defaultStandard( size_t index ) { return m_defaultStandard.get( index ); } // For read/write access
    LMX_GDECL void delete_defaultStandard( size_t index )
    {
        lmx_assert( index < m_defaultStandard.size() );
        m_defaultStandard.erase( index );
    }
    LMX_GDECL void clear_defaultStandard() { m_defaultStandard.clear(); }
    LMX_GDECL c_SemiQuantStandard & assign_defaultStandard( size_t index, const c_SemiQuantStandard & value ) { return get_defaultStandard( index ) = value; } // Deep Copy
    LMX_GDECL c_SemiQuantStandard & assign_defaultStandard( size_t index, c_SemiQuantStandard * p ) { return m_defaultStandard.assign( index, p ); }
    LMX_GDECL size_t size_defaultStandard() const { return m_defaultStandard.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "SemiQuantSettings" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "SemiQuantSettings" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_28( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

// From: Analyte.xsd(5)
class c_Analyte
{
public:
    // From: Analyte.xsd(35)
    class c_additionalMasses
    {
        //:snippet:start additionalMasses
        //:snippet:end additionalMasses

    private:
        // Element(s)
        lmx::ct_simple_pod_multi< lmx::tlmx_double > m_mass;

        static const lmx::s_event_map attr_event_map[];
        static const lmx::s_event_map elem_event_map[];
        static const lmx::s_known_elements known_elements[];

    public:
        LMX_GDECL c_additionalMasses();
        LMX_GDECL c_additionalMasses( const c_additionalMasses & r_rhs );
        LMX_GDECL c_additionalMasses & operator = ( const c_additionalMasses & r_rhs );
        LMX_GDECL virtual c_additionalMasses * clone() const;
        LMX_GDECL void swap( c_additionalMasses & r_rhs );
        LMX_GDECL virtual ~c_additionalMasses();

        // Element(s)

        //    mass --> xs:double{0.0<x}[1..*]
        LMX_GDECL const lmx::tlmx_double & get_mass( size_t index ) const { return m_mass.get( index ); }
        LMX_GDECL lmx::elmx_error set_mass( size_t index, const lmx::tlmx_double & value );
        LMX_GDECL lmx::elmx_error append_mass( const lmx::tlmx_double & value );
        LMX_GDECL lmx::elmx_error insert_mass( size_t index, const lmx::tlmx_double & value );
        LMX_GDECL void delete_mass( size_t index ) { m_mass.erase( index ); }
        LMX_GDECL void clear_mass() { m_mass.clear(); }
        LMX_GDECL size_t size_mass() const { return m_mass.size(); }

        LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

        LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "additionalMasses" ) const;

        // General marshal/unmarshal functions
        LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "additionalMasses" ) const;
        LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
        LMX_GDECL void reset();

    protected:
        LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
        LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
        LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
        LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
        LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

    private:
        LMX_GDECL void init();
        LMX_GDECL void release();
    };


    //:snippet:start Analyte
    //:snippet:end Analyte

private:
    // Attribute(s)
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_id;

    // Element(s)
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_name;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_mass;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_massSpan;
    lmx::ct_complex_optional< c_additionalMasses > m_additionalMasses;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_retentionTime;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_retentionTimeSpan;
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_concentrationUnits;
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_intensityMetric;
    lmx::ct_complex_multi< c_AnalyteSettings > m_settings;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_Analyte();
    LMX_GDECL c_Analyte( const c_Analyte & r_rhs );
    LMX_GDECL c_Analyte & operator = ( const c_Analyte & r_rhs );
    LMX_GDECL virtual c_Analyte * clone() const;
    LMX_GDECL void swap( c_Analyte & r_rhs );
    LMX_GDECL virtual ~c_Analyte();

    // Attribute(s)

    //    id --> xs:ID
    LMX_GDECL const lmx::tlmx_unicode_string & get_id() const { return m_id.get(); }
    LMX_GDECL lmx::elmx_error set_id( const lmx::tlmx_unicode_string & value ) { return m_id.set( value ); }
    // Element(s)

    //    name --> xs:string[0..1]
    LMX_GDECL const lmx::tlmx_unicode_string & get_name() const { return m_name.get(); }
    LMX_GDECL lmx::elmx_error set_name( const lmx::tlmx_unicode_string & value ) { return m_name.set( value ); }
    LMX_GDECL bool isset_name() const { return m_name.is_value_set(); }
    LMX_GDECL void unset_name() { m_name.unset(); }

    //    mass --> xs:double{0.0<x}
    LMX_GDECL const lmx::tlmx_double & get_mass() const { return m_mass.get(); }
    LMX_GDECL lmx::elmx_error set_mass( const lmx::tlmx_double & value );

    //    massSpan --> xs:double{0.0<x}[0..1] (Default: 0.2)
    LMX_GDECL const lmx::tlmx_double & get_massSpan() const { return m_massSpan.get(); }
    LMX_GDECL lmx::elmx_error set_massSpan( const lmx::tlmx_double & value );
    LMX_GDECL bool isset_massSpan() const { return m_massSpan.is_value_set(); }
    LMX_GDECL void unset_massSpan();

    //    additionalMasses --> additionalMasses[0..1]
    LMX_GDECL const c_additionalMasses & get_additionalMasses() const;
    LMX_GDECL c_additionalMasses & get_additionalMasses(); // For read/write access
    LMX_GDECL c_additionalMasses & assign_additionalMasses( const c_additionalMasses & value );
    LMX_GDECL c_additionalMasses & assign_additionalMasses( c_additionalMasses * p );
    LMX_GDECL bool isset_additionalMasses() const;
    LMX_GDECL void unset_additionalMasses();

    //    retentionTime --> xs:double[0..1] (Default: 0.0)
    LMX_GDECL const lmx::tlmx_double & get_retentionTime() const { return m_retentionTime.get(); }
    LMX_GDECL lmx::elmx_error set_retentionTime( const lmx::tlmx_double & value ) { return m_retentionTime.set( value ); }
    LMX_GDECL bool isset_retentionTime() const { return m_retentionTime.is_value_set(); }
    LMX_GDECL void unset_retentionTime();

    //    retentionTimeSpan --> xs:double[0..1] (Default: 0.5)
    LMX_GDECL const lmx::tlmx_double & get_retentionTimeSpan() const { return m_retentionTimeSpan.get(); }
    LMX_GDECL lmx::elmx_error set_retentionTimeSpan( const lmx::tlmx_double & value ) { return m_retentionTimeSpan.set( value ); }
    LMX_GDECL bool isset_retentionTimeSpan() const { return m_retentionTimeSpan.is_value_set(); }
    LMX_GDECL void unset_retentionTimeSpan();

    //    concentrationUnits --> xs:string[0..1] (Default: )
    LMX_GDECL const lmx::tlmx_unicode_string & get_concentrationUnits() const { return m_concentrationUnits.get(); }
    LMX_GDECL lmx::elmx_error set_concentrationUnits( const lmx::tlmx_unicode_string & value ) { return m_concentrationUnits.set( value ); }
    LMX_GDECL bool isset_concentrationUnits() const { return m_concentrationUnits.is_value_set(); }
    LMX_GDECL void unset_concentrationUnits();

    //    intensityMetric --> xs:string[0..1] (Default: TimeAverage)
    LMX_GDECL const lmx::tlmx_unicode_string & get_intensityMetric() const { return m_intensityMetric.get(); }
    LMX_GDECL lmx::elmx_error set_intensityMetric( const lmx::tlmx_unicode_string & value );
    enum Method_enum_intensityMetric {
            Method_intensityMetric_unknown,
            Method_intensityMetric__PeakArea,
            Method_intensityMetric__PeakHeight,
            Method_intensityMetric__TimeAverage };
    LMX_GDECL Method_enum_intensityMetric getenum_intensityMetric() const;
    LMX_GDECL bool setenum_intensityMetric( Method_enum_intensityMetric value );
            // Enum options:
            // AdvionObjects::c_Analyte::Method_intensityMetric__PeakArea
            // AdvionObjects::c_Analyte::Method_intensityMetric__PeakHeight
            // AdvionObjects::c_Analyte::Method_intensityMetric__TimeAverage
    LMX_GDECL bool isset_intensityMetric() const { return m_intensityMetric.is_value_set(); }
    LMX_GDECL void unset_intensityMetric();

    //    settings --> AnalyteSettings[0..*]
    LMX_GDECL const c_AnalyteSettings & get_settings( size_t index ) const { return m_settings.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_settings() { return append_settings( new c_AnalyteSettings ); }                  // For write access
    LMX_GDECL lmx::elmx_error append_settings( c_AnalyteSettings * p_value ) // For write access
    {
        lmx::uniq_ptr< c_AnalyteSettings >::type auto_p_value( p_value );
        m_settings.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_AnalyteSettings & back_settings() { return m_settings.back(); }                // For write access
    LMX_GDECL lmx::elmx_error insert_settings( size_t index ) { return insert_settings( index, new c_AnalyteSettings ); }    // For write access
    LMX_GDECL lmx::elmx_error insert_settings( size_t index, c_AnalyteSettings * p_value ) // For write access
    {
        lmx::uniq_ptr< c_AnalyteSettings >::type auto_p_value( p_value );
        m_settings.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_AnalyteSettings & get_settings( size_t index ) { return m_settings.get( index ); }   // For read/write access
    LMX_GDECL void delete_settings( size_t index )
    {
        lmx_assert( index < m_settings.size() );
        m_settings.erase( index );
    }
    LMX_GDECL void clear_settings() { m_settings.clear(); }
    LMX_GDECL c_AnalyteSettings & assign_settings( size_t index, const c_AnalyteSettings & value ) { return get_settings( index ) = value; } // Deep Copy
    LMX_GDECL c_AnalyteSettings & assign_settings( size_t index, c_AnalyteSettings * p ) { return m_settings.assign( index, p ); }
    LMX_GDECL size_t size_settings() const { return m_settings.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "Analyte" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "Analyte" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: ProcessMethod.xsd(4)
class c_processMethod
{
    //:snippet:start processMethod
    //:snippet:end processMethod

private:
    // Attribute(s)
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_version;

    // Element(s)
    lmx::ct_complex_optional< c_BackgroundOptions > m_backgroundOptions;
    lmx::ct_complex_optional< c_SpectrumGraphInfo > m_parentSpectrumInfo;
    lmx::ct_complex_multi< c_SpectrumGraphInfo > m_spectrumInfos;
    lmx::ct_complex_optional< c_ParentChromGraphInfo > m_parentChromInfo;
    lmx::ct_complex_multi< c_ChromGraphInfo > m_chromInfos;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_processMethod();
    LMX_GDECL c_processMethod( const c_processMethod & r_rhs );
    LMX_GDECL c_processMethod & operator = ( const c_processMethod & r_rhs );
    LMX_GDECL virtual c_processMethod * clone() const;
    LMX_GDECL void swap( c_processMethod & r_rhs );
    LMX_GDECL c_processMethod( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    // Convenience constructors
    LMX_GDECL c_processMethod( const char c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL c_processMethod( const wchar_t c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL c_processMethod( const char * p_memory, size_t memory_size, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_processMethod( const std::string & r_string, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_processMethod( const lmx::c_any_info & r_any_info, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL virtual ~c_processMethod();

    // Attribute(s)

    //    version --> xs:string[0..1] (Default: 1.0)
    LMX_GDECL const lmx::tlmx_unicode_string & get_version() const { return m_version.get(); }
    LMX_GDECL lmx::elmx_error set_version( const lmx::tlmx_unicode_string & value ) { return m_version.set( value ); }
    LMX_GDECL bool isset_version() const { return m_version.is_value_set(); }
    LMX_GDECL void unset_version();
    // Element(s)

    //    backgroundOptions --> BackgroundOptions[0..1]
    LMX_GDECL const c_BackgroundOptions & get_backgroundOptions() const { return m_backgroundOptions.get(); }
    LMX_GDECL c_BackgroundOptions & get_backgroundOptions() { return m_backgroundOptions.get(); } // For read/write access
    LMX_GDECL c_BackgroundOptions & assign_backgroundOptions( const c_BackgroundOptions & value ) { return (get_backgroundOptions() = value); }
    LMX_GDECL c_BackgroundOptions & assign_backgroundOptions( c_BackgroundOptions * p ) { return m_backgroundOptions.assign( p ); }
    LMX_GDECL bool isset_backgroundOptions() const { return m_backgroundOptions.is_value_set(); }
    LMX_GDECL void unset_backgroundOptions() { m_backgroundOptions.unset(); }

    //    parentSpectrumInfo --> SpectrumGraphInfo[0..1]
    LMX_GDECL const c_SpectrumGraphInfo & get_parentSpectrumInfo() const { return m_parentSpectrumInfo.get(); }
    LMX_GDECL c_SpectrumGraphInfo & get_parentSpectrumInfo() { return m_parentSpectrumInfo.get(); } // For read/write access
    LMX_GDECL c_SpectrumGraphInfo & assign_parentSpectrumInfo( const c_SpectrumGraphInfo & value ) { return (get_parentSpectrumInfo() = value); }
    LMX_GDECL c_SpectrumGraphInfo & assign_parentSpectrumInfo( c_SpectrumGraphInfo * p ) { return m_parentSpectrumInfo.assign( p ); }
    LMX_GDECL bool isset_parentSpectrumInfo() const { return m_parentSpectrumInfo.is_value_set(); }
    LMX_GDECL void unset_parentSpectrumInfo() { m_parentSpectrumInfo.unset(); }

    //    spectrumInfos --> SpectrumGraphInfo[0..*]
    LMX_GDECL const c_SpectrumGraphInfo & get_spectrumInfos( size_t index ) const { return m_spectrumInfos.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_spectrumInfos() { return append_spectrumInfos( new c_SpectrumGraphInfo ); }             // For write access
    LMX_GDECL lmx::elmx_error append_spectrumInfos( c_SpectrumGraphInfo * p_value ) // For write access
    {
        lmx::uniq_ptr< c_SpectrumGraphInfo >::type auto_p_value( p_value );
        m_spectrumInfos.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_SpectrumGraphInfo & back_spectrumInfos() { return m_spectrumInfos.back(); }         // For write access
    LMX_GDECL lmx::elmx_error insert_spectrumInfos( size_t index ) { return insert_spectrumInfos( index, new c_SpectrumGraphInfo ); } // For write access
    LMX_GDECL lmx::elmx_error insert_spectrumInfos( size_t index, c_SpectrumGraphInfo * p_value ) // For write access
    {
        lmx::uniq_ptr< c_SpectrumGraphInfo >::type auto_p_value( p_value );
        m_spectrumInfos.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_SpectrumGraphInfo & get_spectrumInfos( size_t index ) { return m_spectrumInfos.get( index ); } // For read/write access
    LMX_GDECL void delete_spectrumInfos( size_t index )
    {
        lmx_assert( index < m_spectrumInfos.size() );
        m_spectrumInfos.erase( index );
    }
    LMX_GDECL void clear_spectrumInfos() { m_spectrumInfos.clear(); }
    LMX_GDECL c_SpectrumGraphInfo & assign_spectrumInfos( size_t index, const c_SpectrumGraphInfo & value ) { return get_spectrumInfos( index ) = value; } // Deep Copy
    LMX_GDECL c_SpectrumGraphInfo & assign_spectrumInfos( size_t index, c_SpectrumGraphInfo * p ) { return m_spectrumInfos.assign( index, p ); }
    LMX_GDECL size_t size_spectrumInfos() const { return m_spectrumInfos.size(); }

    //    parentChromInfo --> ParentChromGraphInfo[0..1]
    LMX_GDECL const c_ParentChromGraphInfo & get_parentChromInfo() const { return m_parentChromInfo.get(); }
    LMX_GDECL c_ParentChromGraphInfo & get_parentChromInfo() { return m_parentChromInfo.get(); } // For read/write access
    LMX_GDECL c_ParentChromGraphInfo & assign_parentChromInfo( const c_ParentChromGraphInfo & value ) { return (get_parentChromInfo() = value); }
    LMX_GDECL c_ParentChromGraphInfo & assign_parentChromInfo( c_ParentChromGraphInfo * p ) { return m_parentChromInfo.assign( p ); }
    LMX_GDECL bool isset_parentChromInfo() const { return m_parentChromInfo.is_value_set(); }
    LMX_GDECL void unset_parentChromInfo() { m_parentChromInfo.unset(); }

    //    chromInfos --> ChromGraphInfo[0..*]
    LMX_GDECL const c_ChromGraphInfo & get_chromInfos( size_t index ) const { return m_chromInfos.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_chromInfos() { return append_chromInfos( new c_ChromGraphInfo ); }                // For write access
    LMX_GDECL lmx::elmx_error append_chromInfos( c_ChromGraphInfo * p_value ) // For write access
    {
        lmx::uniq_ptr< c_ChromGraphInfo >::type auto_p_value( p_value );
        m_chromInfos.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_ChromGraphInfo & back_chromInfos() { return m_chromInfos.back(); }               // For write access
    LMX_GDECL lmx::elmx_error insert_chromInfos( size_t index ) { return insert_chromInfos( index, new c_ChromGraphInfo ); }  // For write access
    LMX_GDECL lmx::elmx_error insert_chromInfos( size_t index, c_ChromGraphInfo * p_value ) // For write access
    {
        lmx::uniq_ptr< c_ChromGraphInfo >::type auto_p_value( p_value );
        m_chromInfos.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_ChromGraphInfo & get_chromInfos( size_t index ) { return m_chromInfos.get( index ); }  // For read/write access
    LMX_GDECL void delete_chromInfos( size_t index )
    {
        lmx_assert( index < m_chromInfos.size() );
        m_chromInfos.erase( index );
    }
    LMX_GDECL void clear_chromInfos() { m_chromInfos.clear(); }
    LMX_GDECL c_ChromGraphInfo & assign_chromInfos( size_t index, const c_ChromGraphInfo & value ) { return get_chromInfos( index ) = value; } // Deep Copy
    LMX_GDECL c_ChromGraphInfo & assign_chromInfos( size_t index, c_ChromGraphInfo * p ) { return m_chromInfos.assign( index, p ); }
    LMX_GDECL size_t size_chromInfos() const { return m_chromInfos.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const
    {
        LMX_NO_WARN_UNUSED( p_tracker_in );
        return true;
    }

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "processMethod" ) const;

    LMX_GDECL static const lmx::s_ns_map * ns_map() { return Method_reader; }
    // Convenience marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #if defined( _MSC_VER ) && _MSC_VER >= 1400
        LMX_GDECL lmx::elmx_error marshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #endif
    LMX_GDECL lmx::elmx_error marshal( std::string * p_string, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error marshal( std::ostream & r_sos, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error unmarshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL lmx::elmx_error unmarshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL lmx::elmx_error unmarshal( const char * p_memory, size_t memory_size, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL lmx::elmx_error unmarshal( const std::string & r_string, lmx::s_debug_error * p_debug_error = LMXNULL )
    {
        return unmarshal( r_string.data(), r_string.size(), p_debug_error );
    }
    LMX_GDECL lmx::elmx_error unmarshal( const lmx::c_any_info & r_any_info, lmx::s_debug_error * p_debug_error = LMXNULL );

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "processMethod" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader );
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_29( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

// From: Quantitation.xsd(4)
class c_QuantitationType
{
    //:snippet:start QuantitationType
    //:snippet:end QuantitationType

private:
    // Attribute(s)
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_calibrationPath;

    // Element(s)
    lmx::ct_simple_pod_optional< bool > m_qcOnly;
    lmx::ct_simple_pod_optional< bool > m_isotopeRatio;
    lmx::ct_simple_pod_optional< bool > m_isotopeDilution;
    lmx::ct_simple_pod_optional< bool > m_standardAddition;
    lmx::ct_simple_pod_optional< bool > m_quantitation;
    lmx::ct_simple_pod_optional< bool > m_backgroundSubtraction;
    lmx::ct_complex_multi< c_Analyte > m_analyte;
    lmx::ct_complex_multi< c_Analyte > m_internalStandard;
    lmx::ct_complex_multi< c_CalibrationStandard > m_calibrationStandard;
    lmx::ct_complex_optional< c_SemiQuantSettings > m_semiQuantSettings;
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_instrumentType;
    lmx::ct_complex_multi< c_QuantScanMode > m_scanMode;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_QuantitationType();
    LMX_GDECL c_QuantitationType( const c_QuantitationType & r_rhs );
    LMX_GDECL c_QuantitationType & operator = ( const c_QuantitationType & r_rhs );
    LMX_GDECL virtual c_QuantitationType * clone() const;
    LMX_GDECL void swap( c_QuantitationType & r_rhs );
    LMX_GDECL virtual ~c_QuantitationType();

    // Attribute(s)

    //    calibrationPath --> xs:string[0..1]
    LMX_GDECL const lmx::tlmx_unicode_string & get_calibrationPath() const { return m_calibrationPath.get(); }
    LMX_GDECL lmx::elmx_error set_calibrationPath( const lmx::tlmx_unicode_string & value ) { return m_calibrationPath.set( value ); }
    LMX_GDECL bool isset_calibrationPath() const { return m_calibrationPath.is_value_set(); }
    LMX_GDECL void unset_calibrationPath() { m_calibrationPath.unset(); }
    // Element(s)

    //    qcOnly --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_qcOnly() const { return m_qcOnly.get(); }
    LMX_GDECL lmx::elmx_error set_qcOnly( const bool & value ) { return m_qcOnly.set( value ); }
    LMX_GDECL bool isset_qcOnly() const { return m_qcOnly.is_value_set(); }
    LMX_GDECL void unset_qcOnly();

    //    isotopeRatio --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_isotopeRatio() const { return m_isotopeRatio.get(); }
    LMX_GDECL lmx::elmx_error set_isotopeRatio( const bool & value ) { return m_isotopeRatio.set( value ); }
    LMX_GDECL bool isset_isotopeRatio() const { return m_isotopeRatio.is_value_set(); }
    LMX_GDECL void unset_isotopeRatio();

    //    isotopeDilution --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_isotopeDilution() const { return m_isotopeDilution.get(); }
    LMX_GDECL lmx::elmx_error set_isotopeDilution( const bool & value ) { return m_isotopeDilution.set( value ); }
    LMX_GDECL bool isset_isotopeDilution() const { return m_isotopeDilution.is_value_set(); }
    LMX_GDECL void unset_isotopeDilution();

    //    standardAddition --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_standardAddition() const { return m_standardAddition.get(); }
    LMX_GDECL lmx::elmx_error set_standardAddition( const bool & value ) { return m_standardAddition.set( value ); }
    LMX_GDECL bool isset_standardAddition() const { return m_standardAddition.is_value_set(); }
    LMX_GDECL void unset_standardAddition();

    //    quantitation --> xs:boolean[0..1] (Default: true)
    LMX_GDECL const bool & get_quantitation() const { return m_quantitation.get(); }
    LMX_GDECL lmx::elmx_error set_quantitation( const bool & value ) { return m_quantitation.set( value ); }
    LMX_GDECL bool isset_quantitation() const { return m_quantitation.is_value_set(); }
    LMX_GDECL void unset_quantitation();

    //    backgroundSubtraction --> xs:boolean[0..1] (Default: false)
    LMX_GDECL const bool & get_backgroundSubtraction() const { return m_backgroundSubtraction.get(); }
    LMX_GDECL lmx::elmx_error set_backgroundSubtraction( const bool & value ) { return m_backgroundSubtraction.set( value ); }
    LMX_GDECL bool isset_backgroundSubtraction() const { return m_backgroundSubtraction.is_value_set(); }
    LMX_GDECL void unset_backgroundSubtraction();

    //    analyte --> Analyte[0..*]
    LMX_GDECL const c_Analyte & get_analyte( size_t index ) const { return m_analyte.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_analyte() { return append_analyte( new c_Analyte ); }                   // For write access
    LMX_GDECL lmx::elmx_error append_analyte( c_Analyte * p_value ) // For write access
    {
        lmx::uniq_ptr< c_Analyte >::type auto_p_value( p_value );
        m_analyte.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_Analyte & back_analyte() { return m_analyte.back(); }                         // For write access
    LMX_GDECL lmx::elmx_error insert_analyte( size_t index ) { return insert_analyte( index, new c_Analyte ); }     // For write access
    LMX_GDECL lmx::elmx_error insert_analyte( size_t index, c_Analyte * p_value ) // For write access
    {
        lmx::uniq_ptr< c_Analyte >::type auto_p_value( p_value );
        m_analyte.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_Analyte & get_analyte( size_t index ) { return m_analyte.get( index ); }            // For read/write access
    LMX_GDECL void delete_analyte( size_t index )
    {
        lmx_assert( index < m_analyte.size() );
        m_analyte.erase( index );
    }
    LMX_GDECL void clear_analyte() { m_analyte.clear(); }
    LMX_GDECL c_Analyte & assign_analyte( size_t index, const c_Analyte & value ) { return get_analyte( index ) = value; } // Deep Copy
    LMX_GDECL c_Analyte & assign_analyte( size_t index, c_Analyte * p ) { return m_analyte.assign( index, p ); }
    LMX_GDECL size_t size_analyte() const { return m_analyte.size(); }

    //    internalStandard --> Analyte[0..*]
    LMX_GDECL const c_Analyte & get_internalStandard( size_t index ) const { return m_internalStandard.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_internalStandard() { return append_internalStandard( new c_Analyte ); }          // For write access
    LMX_GDECL lmx::elmx_error append_internalStandard( c_Analyte * p_value ) // For write access
    {
        lmx::uniq_ptr< c_Analyte >::type auto_p_value( p_value );
        m_internalStandard.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_Analyte & back_internalStandard() { return m_internalStandard.back(); }                // For write access
    LMX_GDECL lmx::elmx_error insert_internalStandard( size_t index ) { return insert_internalStandard( index, new c_Analyte ); } // For write access
    LMX_GDECL lmx::elmx_error insert_internalStandard( size_t index, c_Analyte * p_value ) // For write access
    {
        lmx::uniq_ptr< c_Analyte >::type auto_p_value( p_value );
        m_internalStandard.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_Analyte & get_internalStandard( size_t index ) { return m_internalStandard.get( index ); }   // For read/write access
    LMX_GDECL void delete_internalStandard( size_t index )
    {
        lmx_assert( index < m_internalStandard.size() );
        m_internalStandard.erase( index );
    }
    LMX_GDECL void clear_internalStandard() { m_internalStandard.clear(); }
    LMX_GDECL c_Analyte & assign_internalStandard( size_t index, const c_Analyte & value ) { return get_internalStandard( index ) = value; } // Deep Copy
    LMX_GDECL c_Analyte & assign_internalStandard( size_t index, c_Analyte * p ) { return m_internalStandard.assign( index, p ); }
    LMX_GDECL size_t size_internalStandard() const { return m_internalStandard.size(); }

    //    calibrationStandard --> CalibrationStandard[0..*]
    LMX_GDECL const c_CalibrationStandard & get_calibrationStandard( size_t index ) const { return m_calibrationStandard.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_calibrationStandard() { return append_calibrationStandard( new c_CalibrationStandard ); }       // For write access
    LMX_GDECL lmx::elmx_error append_calibrationStandard( c_CalibrationStandard * p_value ) // For write access
    {
        lmx::uniq_ptr< c_CalibrationStandard >::type auto_p_value( p_value );
        m_calibrationStandard.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_CalibrationStandard & back_calibrationStandard() { return m_calibrationStandard.back(); } // For write access
    LMX_GDECL lmx::elmx_error insert_calibrationStandard( size_t index ) { return insert_calibrationStandard( index, new c_CalibrationStandard ); } // For write access
    LMX_GDECL lmx::elmx_error insert_calibrationStandard( size_t index, c_CalibrationStandard * p_value ) // For write access
    {
        lmx::uniq_ptr< c_CalibrationStandard >::type auto_p_value( p_value );
        m_calibrationStandard.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_CalibrationStandard & get_calibrationStandard( size_t index ) { return m_calibrationStandard.get( index ); } // For read/write access
    LMX_GDECL void delete_calibrationStandard( size_t index )
    {
        lmx_assert( index < m_calibrationStandard.size() );
        m_calibrationStandard.erase( index );
    }
    LMX_GDECL void clear_calibrationStandard() { m_calibrationStandard.clear(); }
    LMX_GDECL c_CalibrationStandard & assign_calibrationStandard( size_t index, const c_CalibrationStandard & value ) { return get_calibrationStandard( index ) = value; } // Deep Copy
    LMX_GDECL c_CalibrationStandard & assign_calibrationStandard( size_t index, c_CalibrationStandard * p ) { return m_calibrationStandard.assign( index, p ); }
    LMX_GDECL size_t size_calibrationStandard() const { return m_calibrationStandard.size(); }

    //    semiQuantSettings --> SemiQuantSettings[0..1]
    LMX_GDECL const c_SemiQuantSettings & get_semiQuantSettings() const { return m_semiQuantSettings.get(); }
    LMX_GDECL c_SemiQuantSettings & get_semiQuantSettings() { return m_semiQuantSettings.get(); } // For read/write access
    LMX_GDECL c_SemiQuantSettings & assign_semiQuantSettings( const c_SemiQuantSettings & value ) { return (get_semiQuantSettings() = value); }
    LMX_GDECL c_SemiQuantSettings & assign_semiQuantSettings( c_SemiQuantSettings * p ) { return m_semiQuantSettings.assign( p ); }
    LMX_GDECL bool isset_semiQuantSettings() const { return m_semiQuantSettings.is_value_set(); }
    LMX_GDECL void unset_semiQuantSettings() { m_semiQuantSettings.unset(); }

    //    instrumentType --> xs:string[0..1] (Default: CMS)
    LMX_GDECL const lmx::tlmx_unicode_string & get_instrumentType() const { return m_instrumentType.get(); }
    LMX_GDECL lmx::elmx_error set_instrumentType( const lmx::tlmx_unicode_string & value );
    enum Method_enum_instrumentType {
            Method_instrumentType_unknown,
            Method_instrumentType__CMS,
            Method_instrumentType__ICPMS,
            Method_instrumentType__UV };
    LMX_GDECL Method_enum_instrumentType getenum_instrumentType() const;
    LMX_GDECL bool setenum_instrumentType( Method_enum_instrumentType value );
            // Enum options:
            // AdvionObjects::c_QuantitationType::Method_instrumentType__CMS
            // AdvionObjects::c_QuantitationType::Method_instrumentType__ICPMS
            // AdvionObjects::c_QuantitationType::Method_instrumentType__UV
    LMX_GDECL bool isset_instrumentType() const { return m_instrumentType.is_value_set(); }
    LMX_GDECL void unset_instrumentType();

    //    scanMode --> QuantScanMode[0..4]
    LMX_GDECL const c_QuantScanMode & get_scanMode( size_t index ) const { return m_scanMode.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_scanMode() { return append_scanMode( new c_QuantScanMode ); }                  // For write access
    LMX_GDECL lmx::elmx_error append_scanMode( c_QuantScanMode * p_value ); // For write access
    LMX_GDECL c_QuantScanMode & back_scanMode() { return m_scanMode.back(); }                  // For write access
    LMX_GDECL lmx::elmx_error insert_scanMode( size_t index ) { return insert_scanMode( index, new c_QuantScanMode ); }    // For write access
    LMX_GDECL lmx::elmx_error insert_scanMode( size_t index, c_QuantScanMode * p_value ); // For write access
    LMX_GDECL c_QuantScanMode & get_scanMode( size_t index ) // For read/write access
    {
        lmx_assert( index < 4 );
        return m_scanMode.get( index );
    }
    LMX_GDECL void delete_scanMode( size_t index )
    {
        lmx_assert( index < m_scanMode.size() );
        m_scanMode.erase( index );
    }
    LMX_GDECL void clear_scanMode() { m_scanMode.clear(); }
    LMX_GDECL c_QuantScanMode & assign_scanMode( size_t index, const c_QuantScanMode & value ) { return get_scanMode( index ) = value; } // Deep Copy
    LMX_GDECL c_QuantScanMode & assign_scanMode( size_t index, c_QuantScanMode * p ) { return m_scanMode.assign( index, p ); }
    LMX_GDECL size_t size_scanMode() const { return m_scanMode.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "QuantitationType" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "QuantitationType" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(14)
class c_MethodType
{
    //:snippet:start MethodType
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end MethodType

private:
    // Element(s)
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_description;
    lmx::ct_simple_pod_optional< lmx::tlmx_uns32 > m_runTime;
    lmx::ct_complex_multi< c_ScanMode > m_scanMode;
    lmx::ct_complex_optional< c_Smoothing > m_smoothing;
    lmx::ct_simple_pod_optional< bool > m_removeNoise;
    lmx::ct_complex_optional< c_AnalogOutputs > m_analogOutputs;
    lmx::ct_complex_optional< c_AnalogInputs > m_analogInputs;
    lmx::ct_complex_optional< c_ContactClosureIn > m_contactClosureIn;
    lmx::ct_complex_optional< c_ContactClosuresOut > m_contactClosuresOut;
    lmx::ct_complex_multi< c_AdditionalInfo > m_additionalInfo;
    lmx::ct_complex_optional< c_QuantitationType > m_quantitation;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_MethodType();
    LMX_GDECL c_MethodType( const c_MethodType & r_rhs );
    LMX_GDECL c_MethodType & operator = ( const c_MethodType & r_rhs );
    LMX_GDECL virtual c_MethodType * clone() const;
    LMX_GDECL void swap( c_MethodType & r_rhs );
    LMX_GDECL virtual ~c_MethodType();

    // Element(s)

    //    description --> xs:string (Default: )
    LMX_GDECL const lmx::tlmx_unicode_string & get_description() const { return m_description.get(); }
    LMX_GDECL lmx::elmx_error set_description( const lmx::tlmx_unicode_string & value ) { return m_description.set( value ); }

    //    runTime --> xs:int{0<=x<=2147483647}[0..1] (Default: 600)
    LMX_GDECL const lmx::tlmx_uns32 & get_runTime() const { return m_runTime.get(); }
    LMX_GDECL lmx::elmx_error set_runTime( const lmx::tlmx_uns32 & value );
    LMX_GDECL bool isset_runTime() const { return m_runTime.is_value_set(); }
    LMX_GDECL void unset_runTime();

    //    scanMode --> ScanMode[1..2]
    LMX_GDECL const c_ScanMode & get_scanMode( size_t index ) const { return m_scanMode.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_scanMode() { return append_scanMode( new c_ScanMode ); }                  // For write access
    LMX_GDECL lmx::elmx_error append_scanMode( c_ScanMode * p_value ); // For write access
    LMX_GDECL c_ScanMode & back_scanMode() { return m_scanMode.back(); }                       // For write access
    LMX_GDECL lmx::elmx_error insert_scanMode( size_t index ) { return insert_scanMode( index, new c_ScanMode ); }    // For write access
    LMX_GDECL lmx::elmx_error insert_scanMode( size_t index, c_ScanMode * p_value ); // For write access
    LMX_GDECL c_ScanMode & get_scanMode( size_t index )      // For read/write access
    {
        lmx_assert( index < 2 );
        return m_scanMode.get( index );
    }
    LMX_GDECL void delete_scanMode( size_t index )
    {
        lmx_assert( index < m_scanMode.size() );
        m_scanMode.erase( index );
    }
    LMX_GDECL void clear_scanMode() { m_scanMode.clear(); }
    LMX_GDECL c_ScanMode & assign_scanMode( size_t index, const c_ScanMode & value ) { return get_scanMode( index ) = value; } // Deep Copy
    LMX_GDECL c_ScanMode & assign_scanMode( size_t index, c_ScanMode * p ) { return m_scanMode.assign( index, p ); }
    LMX_GDECL size_t size_scanMode() const { return m_scanMode.size(); }

    //    smoothing --> Smoothing[0..1]
    LMX_GDECL const c_Smoothing & get_smoothing() const { return m_smoothing.get(); }
    LMX_GDECL c_Smoothing & get_smoothing() { return m_smoothing.get(); } // For read/write access
    LMX_GDECL c_Smoothing & assign_smoothing( const c_Smoothing & value ) { return (get_smoothing() = value); }
    LMX_GDECL c_Smoothing & assign_smoothing( c_Smoothing * p ) { return m_smoothing.assign( p ); }
    LMX_GDECL bool isset_smoothing() const { return m_smoothing.is_value_set(); }
    LMX_GDECL void unset_smoothing() { m_smoothing.unset(); }

    //    removeNoise --> xs:boolean[0..1] (Default: true)
    LMX_GDECL const bool & get_removeNoise() const { return m_removeNoise.get(); }
    LMX_GDECL lmx::elmx_error set_removeNoise( const bool & value ) { return m_removeNoise.set( value ); }
    LMX_GDECL bool isset_removeNoise() const { return m_removeNoise.is_value_set(); }
    LMX_GDECL void unset_removeNoise();

    //    analogOutputs --> AnalogOutputs[0..1]
    LMX_GDECL const c_AnalogOutputs & get_analogOutputs() const { return m_analogOutputs.get(); }
    LMX_GDECL c_AnalogOutputs & get_analogOutputs() { return m_analogOutputs.get(); } // For read/write access
    LMX_GDECL c_AnalogOutputs & assign_analogOutputs( const c_AnalogOutputs & value ) { return (get_analogOutputs() = value); }
    LMX_GDECL c_AnalogOutputs & assign_analogOutputs( c_AnalogOutputs * p ) { return m_analogOutputs.assign( p ); }
    LMX_GDECL bool isset_analogOutputs() const { return m_analogOutputs.is_value_set(); }
    LMX_GDECL void unset_analogOutputs() { m_analogOutputs.unset(); }

    //    analogInputs --> AnalogInputs[0..1]
    LMX_GDECL const c_AnalogInputs & get_analogInputs() const { return m_analogInputs.get(); }
    LMX_GDECL c_AnalogInputs & get_analogInputs() { return m_analogInputs.get(); } // For read/write access
    LMX_GDECL c_AnalogInputs & assign_analogInputs( const c_AnalogInputs & value ) { return (get_analogInputs() = value); }
    LMX_GDECL c_AnalogInputs & assign_analogInputs( c_AnalogInputs * p ) { return m_analogInputs.assign( p ); }
    LMX_GDECL bool isset_analogInputs() const { return m_analogInputs.is_value_set(); }
    LMX_GDECL void unset_analogInputs() { m_analogInputs.unset(); }

    //    contactClosureIn --> ContactClosureIn[0..1]
    LMX_GDECL const c_ContactClosureIn & get_contactClosureIn() const { return m_contactClosureIn.get(); }
    LMX_GDECL c_ContactClosureIn & get_contactClosureIn() { return m_contactClosureIn.get(); } // For read/write access
    LMX_GDECL c_ContactClosureIn & assign_contactClosureIn( const c_ContactClosureIn & value ) { return (get_contactClosureIn() = value); }
    LMX_GDECL c_ContactClosureIn & assign_contactClosureIn( c_ContactClosureIn * p ) { return m_contactClosureIn.assign( p ); }
    LMX_GDECL bool isset_contactClosureIn() const { return m_contactClosureIn.is_value_set(); }
    LMX_GDECL void unset_contactClosureIn() { m_contactClosureIn.unset(); }

    //    contactClosuresOut --> ContactClosuresOut[0..1]
    LMX_GDECL const c_ContactClosuresOut & get_contactClosuresOut() const { return m_contactClosuresOut.get(); }
    LMX_GDECL c_ContactClosuresOut & get_contactClosuresOut() { return m_contactClosuresOut.get(); } // For read/write access
    LMX_GDECL c_ContactClosuresOut & assign_contactClosuresOut( const c_ContactClosuresOut & value ) { return (get_contactClosuresOut() = value); }
    LMX_GDECL c_ContactClosuresOut & assign_contactClosuresOut( c_ContactClosuresOut * p ) { return m_contactClosuresOut.assign( p ); }
    LMX_GDECL bool isset_contactClosuresOut() const { return m_contactClosuresOut.is_value_set(); }
    LMX_GDECL void unset_contactClosuresOut() { m_contactClosuresOut.unset(); }

    //    additionalInfo --> AdditionalInfo[0..*]
    LMX_GDECL const c_AdditionalInfo & get_additionalInfo( size_t index ) const { return m_additionalInfo.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_additionalInfo() { return append_additionalInfo( new c_AdditionalInfo ); }            // For write access
    LMX_GDECL lmx::elmx_error append_additionalInfo( c_AdditionalInfo * p_value ) // For write access
    {
        lmx::uniq_ptr< c_AdditionalInfo >::type auto_p_value( p_value );
        m_additionalInfo.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_AdditionalInfo & back_additionalInfo() { return m_additionalInfo.back(); }           // For write access
    LMX_GDECL lmx::elmx_error insert_additionalInfo( size_t index ) { return insert_additionalInfo( index, new c_AdditionalInfo ); } // For write access
    LMX_GDECL lmx::elmx_error insert_additionalInfo( size_t index, c_AdditionalInfo * p_value ) // For write access
    {
        lmx::uniq_ptr< c_AdditionalInfo >::type auto_p_value( p_value );
        m_additionalInfo.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_AdditionalInfo & get_additionalInfo( size_t index ) { return m_additionalInfo.get( index ); } // For read/write access
    LMX_GDECL void delete_additionalInfo( size_t index )
    {
        lmx_assert( index < m_additionalInfo.size() );
        m_additionalInfo.erase( index );
    }
    LMX_GDECL void clear_additionalInfo() { m_additionalInfo.clear(); }
    LMX_GDECL c_AdditionalInfo & assign_additionalInfo( size_t index, const c_AdditionalInfo & value ) { return get_additionalInfo( index ) = value; } // Deep Copy
    LMX_GDECL c_AdditionalInfo & assign_additionalInfo( size_t index, c_AdditionalInfo * p ) { return m_additionalInfo.assign( index, p ); }
    LMX_GDECL size_t size_additionalInfo() const { return m_additionalInfo.size(); }

    //    quantitation --> QuantitationType[0..1]
    LMX_GDECL const c_QuantitationType & get_quantitation() const { return m_quantitation.get(); }
    LMX_GDECL c_QuantitationType & get_quantitation() { return m_quantitation.get(); } // For read/write access
    LMX_GDECL c_QuantitationType & assign_quantitation( const c_QuantitationType & value ) { return (get_quantitation() = value); }
    LMX_GDECL c_QuantitationType & assign_quantitation( c_QuantitationType * p ) { return m_quantitation.assign( p ); }
    LMX_GDECL bool isset_quantitation() const { return m_quantitation.is_value_set(); }
    LMX_GDECL void unset_quantitation() { m_quantitation.unset(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "MethodType" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "MethodType" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: Method.xsd(5)
class c_method : public c_MethodType
{
    //:snippet:start method
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end method

private:
    // Attribute(s)
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_version;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_method();
    LMX_GDECL c_method( const c_method & r_rhs );
    LMX_GDECL c_method & operator = ( const c_method & r_rhs );
    LMX_GDECL virtual c_method * clone() const;
    LMX_GDECL void swap( c_method & r_rhs );
    LMX_GDECL c_method( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    // Convenience constructors
    LMX_GDECL c_method( const char c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL c_method( const wchar_t c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL c_method( const char * p_memory, size_t memory_size, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_method( const std::string & r_string, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_method( const lmx::c_any_info & r_any_info, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL virtual ~c_method();

    // Attribute(s)

    //    version --> xs:string[0..1] (Default: 2.0)
    LMX_GDECL const lmx::tlmx_unicode_string & get_version() const { return m_version.get(); }
    LMX_GDECL lmx::elmx_error set_version( const lmx::tlmx_unicode_string & value ) { return m_version.set( value ); }
    LMX_GDECL bool isset_version() const { return m_version.is_value_set(); }
    LMX_GDECL void unset_version();
    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "method" ) const;

    LMX_GDECL static const lmx::s_ns_map * ns_map() { return Method_reader; }
    // Convenience marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #if defined( _MSC_VER ) && _MSC_VER >= 1400
        LMX_GDECL lmx::elmx_error marshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #endif
    LMX_GDECL lmx::elmx_error marshal( std::string * p_string, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error marshal( std::ostream & r_sos, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error unmarshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL lmx::elmx_error unmarshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL lmx::elmx_error unmarshal( const char * p_memory, size_t memory_size, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL lmx::elmx_error unmarshal( const std::string & r_string, lmx::s_debug_error * p_debug_error = LMXNULL )
    {
        return unmarshal( r_string.data(), r_string.size(), p_debug_error );
    }
    LMX_GDECL lmx::elmx_error unmarshal( const lmx::c_any_info & r_any_info, lmx::s_debug_error * p_debug_error = LMXNULL );

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "method" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader );
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

}   // end of namespace AdvionObjects

#if defined( _MSC_VER ) && _MSC_VER >= 1400
#pragma warning (pop)  // Restore disabled warnings
#endif


#endif      // End of include guard
