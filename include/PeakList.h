//
//                  W A R N I N G:  DO NOT MANUALLY MODIFY THIS FILE
//                  ------------------------------------------------
//
// This file has been automatically generated by Codalogic's LMX W3C Schema to 
// C++ compiler.  
//
// It should not be manually modified as this may cause the code to break, or 
// operate in unexpected ways.
// 
// To change the contents of this file, modify the schema, and then re-compile.

//                 Copyright (c) 2019 Codalogic Ltd.
//
// See the LMX license agreement for restrictions on the use of this file.

// THIS FILE AND THE SOFTWARE CONTAINED HEREIN IS PROVIDED "AS IS", WITHOUT
// WARRANTY OF ANY KIND.
//
// CODALOGIC LTD SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY ANYONE
// OR ANYTHING DUE TO THE USE OF THIS FILE HOWEVER THEY MAY BE CAUSED.
//
// For more information on the LMX compiler, go to:
// 
//     http://www.xml2cpp.com
//
// Also see:
//
//     http://www.codalogic.com
//

// TargetNamepsace: 
// Source File: PeakList.xsd
// LMX Version: 7.2
// Compile options: -autover2 -local-enums -ns-map-base PeakList_ -prefix-enum PeakList_ -no-ev -no-gen-date -no-html -no-root-class -include-h AdvionObjects.h -snippets -output-defaults -cns AdvionObjects PeakList.xsd ..\\..\\cpp\\AdvionObjects\\PeakList

// License details (This file is not valid without this information)
//     License number: 1322669991
//     License owning company: Advion, Inc
//     License owning e-mail addr: trumborb@advion.com
//     License authorising code: 84a013fdcf68a3d1d4aa36b28356d7f7
//
//       Copyright (c) 2019 Advion, Inc.

#ifndef __ADVIONOBJECTS_PEAKLIST_H__
#define __ADVIONOBJECTS_PEAKLIST_H__

#if defined( _MSC_VER ) && _MSC_VER >= 1400
#pragma warning (push)
#pragma warning (disable:4100)  // Disable unreferenced formal parameter
#endif

#include "AdvionObjects.h"

#include "lmxuser.h"

// To help MS intellisense
#ifndef LMX_GDECL
#define LMX_GDECL
#endif

namespace AdvionObjects {

LMX_GDECL extern const lmx::s_ns_map PeakList_reader[];
LMX_GDECL extern const lmx::s_ns_map PeakList_writer_1[];

enum
{
    PeakList_error = lmx::EXE_LAST_XML_EVENT,
    PeakList_NONE_peakList,
    PeakList_NONE_version,
    PeakList_NONE_peak,
    PeakList_NONE_baseline,
    PeakList_NONE_startX,
    PeakList_NONE_endX,
    PeakList_NONE_startY,
    PeakList_NONE_endY,
    PeakList_NONE_startIndex,
    PeakList_NONE_endIndex,
    PeakList_NONE_area,
    PeakList_NONE_centroid,
    PeakList_NONE_maximumX,
    PeakList_NONE_maximumY,
    PeakList_NONE_maximumIndex,
    PeakList_NONE_heightAboveBaseline,
    PeakList_NONE_commonBaseline,
    PeakList_NONE_error,
    PeakList_NONE_widthUsed,
    PeakList_any
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_1( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_2( const lmx::tlmx_int32 &, const char * );
#endif // LMX_USER_VALIDATE

// From: PeakList.xsd(33)
class c_IntegrationBaseline
{
    //:snippet:start IntegrationBaseline
    //:snippet:end IntegrationBaseline

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_startX;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_endX;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_startY;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_endY;
    lmx::ct_simple_pod_optional< lmx::tlmx_int32 > m_startIndex;
    lmx::ct_simple_pod_optional< lmx::tlmx_int32 > m_endIndex;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_IntegrationBaseline();
    LMX_GDECL c_IntegrationBaseline( const c_IntegrationBaseline & r_rhs );
    LMX_GDECL c_IntegrationBaseline & operator = ( const c_IntegrationBaseline & r_rhs );
    LMX_GDECL virtual c_IntegrationBaseline * clone() const;
    LMX_GDECL void swap( c_IntegrationBaseline & r_rhs );
    LMX_GDECL virtual ~c_IntegrationBaseline();

    // Element(s)

    //    startX --> xs:double
    LMX_GDECL const lmx::tlmx_double & get_startX() const { return m_startX.get(); }
    LMX_GDECL lmx::elmx_error set_startX( const lmx::tlmx_double & value ) { return m_startX.set( value ); }

    //    endX --> xs:double
    LMX_GDECL const lmx::tlmx_double & get_endX() const { return m_endX.get(); }
    LMX_GDECL lmx::elmx_error set_endX( const lmx::tlmx_double & value ) { return m_endX.set( value ); }

    //    startY --> xs:double
    LMX_GDECL const lmx::tlmx_double & get_startY() const { return m_startY.get(); }
    LMX_GDECL lmx::elmx_error set_startY( const lmx::tlmx_double & value ) { return m_startY.set( value ); }

    //    endY --> xs:double
    LMX_GDECL const lmx::tlmx_double & get_endY() const { return m_endY.get(); }
    LMX_GDECL lmx::elmx_error set_endY( const lmx::tlmx_double & value ) { return m_endY.set( value ); }

    //    startIndex --> xs:int{-2147483648<=x<=2147483647}[0..1]
    LMX_GDECL const lmx::tlmx_int32 & get_startIndex() const { return m_startIndex.get(); }
    LMX_GDECL lmx::elmx_error set_startIndex( const lmx::tlmx_int32 & value );
    LMX_GDECL bool isset_startIndex() const { return m_startIndex.is_value_set(); }
    LMX_GDECL void unset_startIndex() { m_startIndex.unset(); }

    //    endIndex --> xs:int{-2147483648<=x<=2147483647}[0..1]
    LMX_GDECL const lmx::tlmx_int32 & get_endIndex() const { return m_endIndex.get(); }
    LMX_GDECL lmx::elmx_error set_endIndex( const lmx::tlmx_int32 & value );
    LMX_GDECL bool isset_endIndex() const { return m_endIndex.is_value_set(); }
    LMX_GDECL void unset_endIndex() { m_endIndex.unset(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "IntegrationBaseline" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "IntegrationBaseline" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: PeakList.xsd(17)
class c_Peak
{
    //:snippet:start Peak
    //:snippet:end Peak

private:
    // Element(s)
    lmx::ct_complex_single< c_IntegrationBaseline > m_baseline;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_area;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_centroid;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_maximumX;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_maximumY;
    lmx::ct_simple_pod_optional< lmx::tlmx_int32 > m_maximumIndex;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_heightAboveBaseline;
    lmx::ct_complex_optional< c_IntegrationBaseline > m_commonBaseline;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_Peak();
    LMX_GDECL c_Peak( const c_Peak & r_rhs );
    LMX_GDECL c_Peak & operator = ( const c_Peak & r_rhs );
    LMX_GDECL virtual c_Peak * clone() const;
    LMX_GDECL void swap( c_Peak & r_rhs );
    LMX_GDECL virtual ~c_Peak();

    // Element(s)

    //    baseline --> IntegrationBaseline
    LMX_GDECL const c_IntegrationBaseline & get_baseline() const { return m_baseline.get(); }
    LMX_GDECL c_IntegrationBaseline & get_baseline() { return m_baseline.get(); } // For read/write access
    LMX_GDECL c_IntegrationBaseline & assign_baseline( const c_IntegrationBaseline & value ) { return (get_baseline() = value); }
    LMX_GDECL c_IntegrationBaseline & assign_baseline( c_IntegrationBaseline * p ) { return m_baseline.assign( p ); }

    //    area --> xs:double
    LMX_GDECL const lmx::tlmx_double & get_area() const { return m_area.get(); }
    LMX_GDECL lmx::elmx_error set_area( const lmx::tlmx_double & value ) { return m_area.set( value ); }

    //    centroid --> xs:double
    LMX_GDECL const lmx::tlmx_double & get_centroid() const { return m_centroid.get(); }
    LMX_GDECL lmx::elmx_error set_centroid( const lmx::tlmx_double & value ) { return m_centroid.set( value ); }

    //    maximumX --> xs:double
    LMX_GDECL const lmx::tlmx_double & get_maximumX() const { return m_maximumX.get(); }
    LMX_GDECL lmx::elmx_error set_maximumX( const lmx::tlmx_double & value ) { return m_maximumX.set( value ); }

    //    maximumY --> xs:double
    LMX_GDECL const lmx::tlmx_double & get_maximumY() const { return m_maximumY.get(); }
    LMX_GDECL lmx::elmx_error set_maximumY( const lmx::tlmx_double & value ) { return m_maximumY.set( value ); }

    //    maximumIndex --> xs:int{-2147483648<=x<=2147483647}[0..1]
    LMX_GDECL const lmx::tlmx_int32 & get_maximumIndex() const { return m_maximumIndex.get(); }
    LMX_GDECL lmx::elmx_error set_maximumIndex( const lmx::tlmx_int32 & value );
    LMX_GDECL bool isset_maximumIndex() const { return m_maximumIndex.is_value_set(); }
    LMX_GDECL void unset_maximumIndex() { m_maximumIndex.unset(); }

    //    heightAboveBaseline --> xs:double[0..1]
    LMX_GDECL const lmx::tlmx_double & get_heightAboveBaseline() const { return m_heightAboveBaseline.get(); }
    LMX_GDECL lmx::elmx_error set_heightAboveBaseline( const lmx::tlmx_double & value ) { return m_heightAboveBaseline.set( value ); }
    LMX_GDECL bool isset_heightAboveBaseline() const { return m_heightAboveBaseline.is_value_set(); }
    LMX_GDECL void unset_heightAboveBaseline() { m_heightAboveBaseline.unset(); }

    //    commonBaseline --> IntegrationBaseline[0..1]
    LMX_GDECL const c_IntegrationBaseline & get_commonBaseline() const { return m_commonBaseline.get(); }
    LMX_GDECL c_IntegrationBaseline & get_commonBaseline() { return m_commonBaseline.get(); } // For read/write access
    LMX_GDECL c_IntegrationBaseline & assign_commonBaseline( const c_IntegrationBaseline & value ) { return (get_commonBaseline() = value); }
    LMX_GDECL c_IntegrationBaseline & assign_commonBaseline( c_IntegrationBaseline * p ) { return m_commonBaseline.assign( p ); }
    LMX_GDECL bool isset_commonBaseline() const { return m_commonBaseline.is_value_set(); }
    LMX_GDECL void unset_commonBaseline() { m_commonBaseline.unset(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "Peak" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "Peak" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_3( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_4( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

// From: PeakList.xsd(3)
class c_peakList
{
    //:snippet:start peakList
    //:snippet:end peakList

private:
    // Attribute(s)
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_version;

    // Element(s)
    lmx::ct_complex_multi< c_Peak > m_peak;
    lmx::ct_simple_non_pod_single< lmx::tlmx_unicode_string > m_error;
    lmx::ct_simple_pod_optional< lmx::tlmx_double > m_widthUsed;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_peakList();
    LMX_GDECL c_peakList( const c_peakList & r_rhs );
    LMX_GDECL c_peakList & operator = ( const c_peakList & r_rhs );
    LMX_GDECL virtual c_peakList * clone() const;
    LMX_GDECL void swap( c_peakList & r_rhs );
    LMX_GDECL c_peakList( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    // Convenience constructors
    LMX_GDECL c_peakList( const char c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL c_peakList( const wchar_t c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL c_peakList( const char * p_memory, size_t memory_size, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_peakList( const std::string & r_string, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_peakList( const lmx::c_any_info & r_any_info, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL virtual ~c_peakList();

    // Attribute(s)

    //    version --> xs:string[0..1] (Default: 1.0)
    LMX_GDECL const lmx::tlmx_unicode_string & get_version() const { return m_version.get(); }
    LMX_GDECL lmx::elmx_error set_version( const lmx::tlmx_unicode_string & value ) { return m_version.set( value ); }
    LMX_GDECL bool isset_version() const { return m_version.is_value_set(); }
    LMX_GDECL void unset_version();
    // Element(s)

    //    peak --> Peak[0..*]
    LMX_GDECL const c_Peak & get_peak( size_t index ) const { return m_peak.get( index ); }      // For read access
    LMX_GDECL lmx::elmx_error append_peak() { return append_peak( new c_Peak ); }                      // For write access
    LMX_GDECL lmx::elmx_error append_peak( c_Peak * p_value ) // For write access
    {
        lmx::uniq_ptr< c_Peak >::type auto_p_value( p_value );
        m_peak.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_Peak & back_peak() { return m_peak.back(); }                               // For write access
    LMX_GDECL lmx::elmx_error insert_peak( size_t index ) { return insert_peak( index, new c_Peak ); }        // For write access
    LMX_GDECL lmx::elmx_error insert_peak( size_t index, c_Peak * p_value ) // For write access
    {
        lmx::uniq_ptr< c_Peak >::type auto_p_value( p_value );
        m_peak.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_Peak & get_peak( size_t index ) { return m_peak.get( index ); }                  // For read/write access
    LMX_GDECL void delete_peak( size_t index )
    {
        lmx_assert( index < m_peak.size() );
        m_peak.erase( index );
    }
    LMX_GDECL void clear_peak() { m_peak.clear(); }
    LMX_GDECL c_Peak & assign_peak( size_t index, const c_Peak & value ) { return get_peak( index ) = value; } // Deep Copy
    LMX_GDECL c_Peak & assign_peak( size_t index, c_Peak * p ) { return m_peak.assign( index, p ); }
    LMX_GDECL size_t size_peak() const { return m_peak.size(); }

    //    error --> xs:string (Default: OK)
    LMX_GDECL const lmx::tlmx_unicode_string & get_error() const { return m_error.get(); }
    LMX_GDECL lmx::elmx_error set_error( const lmx::tlmx_unicode_string & value );
    enum PeakList_enum_error {
            PeakList_error_unknown,
            PeakList_error__OK,
            PeakList_error__InvalidPeakDetectionSetup,
            PeakList_error__TargetRetentionTimeRequired };
    LMX_GDECL PeakList_enum_error getenum_error() const;
    LMX_GDECL bool setenum_error( PeakList_enum_error value );
            // Enum options:
            // AdvionObjects::c_peakList::PeakList_error__OK
            // AdvionObjects::c_peakList::PeakList_error__InvalidPeakDetectionSetup
            // AdvionObjects::c_peakList::PeakList_error__TargetRetentionTimeRequired

    //    widthUsed --> xs:double[0..1]
    LMX_GDECL const lmx::tlmx_double & get_widthUsed() const { return m_widthUsed.get(); }
    LMX_GDECL lmx::elmx_error set_widthUsed( const lmx::tlmx_double & value ) { return m_widthUsed.set( value ); }
    LMX_GDECL bool isset_widthUsed() const { return m_widthUsed.is_value_set(); }
    LMX_GDECL void unset_widthUsed() { m_widthUsed.unset(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "peakList" ) const;

    LMX_GDECL static const lmx::s_ns_map * ns_map() { return PeakList_reader; }
    // Convenience marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #if defined( _MSC_VER ) && _MSC_VER >= 1400
        LMX_GDECL lmx::elmx_error marshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #endif
    LMX_GDECL lmx::elmx_error marshal( std::string * p_string, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error marshal( std::ostream & r_sos, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error unmarshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL lmx::elmx_error unmarshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL lmx::elmx_error unmarshal( const char * p_memory, size_t memory_size, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL lmx::elmx_error unmarshal( const std::string & r_string, lmx::s_debug_error * p_debug_error = LMXNULL )
    {
        return unmarshal( r_string.data(), r_string.size(), p_debug_error );
    }
    LMX_GDECL lmx::elmx_error unmarshal( const lmx::c_any_info & r_any_info, lmx::s_debug_error * p_debug_error = LMXNULL );

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "peakList" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader );
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

}   // end of namespace AdvionObjects

#if defined( _MSC_VER ) && _MSC_VER >= 1400
#pragma warning (pop)  // Restore disabled warnings
#endif


#endif      // End of include guard
