//
//                  W A R N I N G:  DO NOT MANUALLY MODIFY THIS FILE
//                  ------------------------------------------------
//
// This file has been automatically generated by Codalogic's LMX W3C Schema to 
// C++ compiler.  
//
// It should not be manually modified as this may cause the code to break, or 
// operate in unexpected ways.
// 
// To change the contents of this file, modify the schema, and then re-compile.

//                 Copyright (c) 2019 Codalogic Ltd.
//
// See the LMX license agreement for restrictions on the use of this file.

// THIS FILE AND THE SOFTWARE CONTAINED HEREIN IS PROVIDED "AS IS", WITHOUT
// WARRANTY OF ANY KIND.
//
// CODALOGIC LTD SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY ANYONE
// OR ANYTHING DUE TO THE USE OF THIS FILE HOWEVER THEY MAY BE CAUSED.
//
// For more information on the LMX compiler, go to:
// 
//     http://www.xml2cpp.com
//
// Also see:
//
//     http://www.codalogic.com
//

// TargetNamepsace: 
// Source File: TuneParameters.xsd
// LMX Version: 7.2
// Compile options: -autover2 -local-enums -ns-map-base TuneParameters_ -prefix-enum TuneParameters_ -no-ev -no-gen-date -no-html -no-root-class -include-h AdvionObjects.h -snippets -output-defaults -cns AdvionObjects TuneParameters.xsd ..\\..\\cpp\\AdvionObjects\\TuneParameters

// License details (This file is not valid without this information)
//     License number: 1322669991
//     License owning company: Advion, Inc
//     License owning e-mail addr: trumborb@advion.com
//     License authorising code: 84a013fdcf68a3d1d4aa36b28356d7f7
//
//       Copyright (c) 2019 Advion, Inc.

#ifndef __ADVIONOBJECTS_TUNEPARAMETERS_H__
#define __ADVIONOBJECTS_TUNEPARAMETERS_H__

#if defined( _MSC_VER ) && _MSC_VER >= 1400
#pragma warning (push)
#pragma warning (disable:4100)  // Disable unreferenced formal parameter
#endif

#include "AdvionObjects.h"

#include "lmxuser.h"

// To help MS intellisense
#ifndef LMX_GDECL
#define LMX_GDECL
#endif

namespace AdvionObjects {

LMX_GDECL extern const lmx::s_ns_map TuneParameters_reader[];
LMX_GDECL extern const lmx::s_ns_map TuneParameters_writer_1[];

enum
{
    TuneParameters_error = lmx::EXE_LAST_XML_EVENT,
    TuneParameters_NONE_tuneParameters,
    TuneParameters_NONE_version,
    TuneParameters_NONE_extractionElectrode,
    TuneParameters_NONE_hexapoleBias,
    TuneParameters_NONE_hexapoleRF,
    TuneParameters_NONE_hexapoleRFDynamic,
    TuneParameters_NONE_ionEnergy,
    TuneParameters_NONE_ionEnergyDynamic,
    TuneParameters_NONE_resolutionOffset,
    TuneParameters_NONE_resolutionGain,
    TuneParameters_NONE_detector,
    TuneParameters_NONE_calibration,
    TuneParameters_NONE_segment,
    TuneParameters_NONE_minMass,
    TuneParameters_NONE_maxMass,
    TuneParameters_NONE_slope,
    TuneParameters_NONE_intercept,
    TuneParameters_NONE_massCalibration,
    TuneParameters_NONE_scanSpeed,
    TuneParameters_any
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_1( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

// From: TuneParameters.xsd(119)
class c_calibrationSegment
{
    //:snippet:start calibrationSegment
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end calibrationSegment

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_minMass;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_maxMass;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_slope;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_intercept;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_calibrationSegment();
    LMX_GDECL c_calibrationSegment( const c_calibrationSegment & r_rhs );
    LMX_GDECL c_calibrationSegment & operator = ( const c_calibrationSegment & r_rhs );
    LMX_GDECL virtual c_calibrationSegment * clone() const;
    LMX_GDECL void swap( c_calibrationSegment & r_rhs );
    LMX_GDECL virtual ~c_calibrationSegment();

    // Element(s)

    //    minMass --> xs:double (Default: 10.0)
    LMX_GDECL const lmx::tlmx_double & get_minMass() const { return m_minMass.get(); }
    LMX_GDECL lmx::elmx_error set_minMass( const lmx::tlmx_double & value ) { return m_minMass.set( value ); }

    //    maxMass --> xs:double (Default: 1200.0)
    LMX_GDECL const lmx::tlmx_double & get_maxMass() const { return m_maxMass.get(); }
    LMX_GDECL lmx::elmx_error set_maxMass( const lmx::tlmx_double & value ) { return m_maxMass.set( value ); }

    //    slope --> xs:double (Default: 1.0)
    LMX_GDECL const lmx::tlmx_double & get_slope() const { return m_slope.get(); }
    LMX_GDECL lmx::elmx_error set_slope( const lmx::tlmx_double & value ) { return m_slope.set( value ); }

    //    intercept --> xs:double (Default: 0.0)
    LMX_GDECL const lmx::tlmx_double & get_intercept() const { return m_intercept.get(); }
    LMX_GDECL lmx::elmx_error set_intercept( const lmx::tlmx_double & value ) { return m_intercept.set( value ); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "calibrationSegment" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "calibrationSegment" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: TuneParameters.xsd(94)
class c_calibration
{
    //:snippet:start calibration
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end calibration

private:
    // Element(s)
    lmx::ct_complex_multi< c_calibrationSegment > m_segment;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_calibration();
    LMX_GDECL c_calibration( const c_calibration & r_rhs );
    LMX_GDECL c_calibration & operator = ( const c_calibration & r_rhs );
    LMX_GDECL virtual c_calibration * clone() const;
    LMX_GDECL void swap( c_calibration & r_rhs );
    LMX_GDECL virtual ~c_calibration();

    // Element(s)

    //    segment --> calibrationSegment[1..*]
    LMX_GDECL const c_calibrationSegment & get_segment( size_t index ) const { return m_segment.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_segment() { return append_segment( new c_calibrationSegment ); }                   // For write access
    LMX_GDECL lmx::elmx_error append_segment( c_calibrationSegment * p_value ) // For write access
    {
        lmx::uniq_ptr< c_calibrationSegment >::type auto_p_value( p_value );
        m_segment.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_calibrationSegment & back_segment() { return m_segment.back(); }              // For write access
    LMX_GDECL lmx::elmx_error insert_segment( size_t index ) { return insert_segment( index, new c_calibrationSegment ); }     // For write access
    LMX_GDECL lmx::elmx_error insert_segment( size_t index, c_calibrationSegment * p_value ) // For write access
    {
        lmx::uniq_ptr< c_calibrationSegment >::type auto_p_value( p_value );
        m_segment.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_calibrationSegment & get_segment( size_t index ) { return m_segment.get( index ); } // For read/write access
    LMX_GDECL void delete_segment( size_t index )
    {
        lmx_assert( index < m_segment.size() );
        m_segment.erase( index );
    }
    LMX_GDECL void clear_segment() { m_segment.clear(); }
    LMX_GDECL c_calibrationSegment & assign_segment( size_t index, const c_calibrationSegment & value ) { return get_segment( index ) = value; } // Deep Copy
    LMX_GDECL c_calibrationSegment & assign_segment( size_t index, c_calibrationSegment * p ) { return m_segment.assign( index, p ); }
    LMX_GDECL size_t size_segment() const { return m_segment.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "calibration" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "calibration" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_2( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

// From: TuneParameters.xsd(104)
class c_speedCalibration
{
    //:snippet:start speedCalibration
    //:snippet:end speedCalibration

private:
    // Attribute(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_scanSpeed;

    // Element(s)
    lmx::ct_complex_multi< c_calibrationSegment > m_segment;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_speedCalibration();
    LMX_GDECL c_speedCalibration( const c_speedCalibration & r_rhs );
    LMX_GDECL c_speedCalibration & operator = ( const c_speedCalibration & r_rhs );
    LMX_GDECL virtual c_speedCalibration * clone() const;
    LMX_GDECL void swap( c_speedCalibration & r_rhs );
    LMX_GDECL virtual ~c_speedCalibration();

    // Attribute(s)

    //    scanSpeed --> xs:double{0.0<x}
    LMX_GDECL const lmx::tlmx_double & get_scanSpeed() const { return m_scanSpeed.get(); }
    LMX_GDECL lmx::elmx_error set_scanSpeed( const lmx::tlmx_double & value );
    // Element(s)

    //    segment --> calibrationSegment[1..*]
    LMX_GDECL const c_calibrationSegment & get_segment( size_t index ) const { return m_segment.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_segment() { return append_segment( new c_calibrationSegment ); }                   // For write access
    LMX_GDECL lmx::elmx_error append_segment( c_calibrationSegment * p_value ) // For write access
    {
        lmx::uniq_ptr< c_calibrationSegment >::type auto_p_value( p_value );
        m_segment.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_calibrationSegment & back_segment() { return m_segment.back(); }              // For write access
    LMX_GDECL lmx::elmx_error insert_segment( size_t index ) { return insert_segment( index, new c_calibrationSegment ); }     // For write access
    LMX_GDECL lmx::elmx_error insert_segment( size_t index, c_calibrationSegment * p_value ) // For write access
    {
        lmx::uniq_ptr< c_calibrationSegment >::type auto_p_value( p_value );
        m_segment.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_calibrationSegment & get_segment( size_t index ) { return m_segment.get( index ); } // For read/write access
    LMX_GDECL void delete_segment( size_t index )
    {
        lmx_assert( index < m_segment.size() );
        m_segment.erase( index );
    }
    LMX_GDECL void clear_segment() { m_segment.clear(); }
    LMX_GDECL c_calibrationSegment & assign_segment( size_t index, const c_calibrationSegment & value ) { return get_segment( index ) = value; } // Deep Copy
    LMX_GDECL c_calibrationSegment & assign_segment( size_t index, c_calibrationSegment * p ) { return m_segment.assign( index, p ); }
    LMX_GDECL size_t size_segment() const { return m_segment.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "speedCalibration" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "speedCalibration" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

// From: TuneParameters.xsd(99)
class c_massCalibration
{
    //:snippet:start massCalibration
    //:snippet:end massCalibration

private:
    // Element(s)
    lmx::ct_complex_multi< c_speedCalibration > m_calibration;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_massCalibration();
    LMX_GDECL c_massCalibration( const c_massCalibration & r_rhs );
    LMX_GDECL c_massCalibration & operator = ( const c_massCalibration & r_rhs );
    LMX_GDECL virtual c_massCalibration * clone() const;
    LMX_GDECL void swap( c_massCalibration & r_rhs );
    LMX_GDECL virtual ~c_massCalibration();

    // Element(s)

    //    calibration --> speedCalibration[1..*]
    LMX_GDECL const c_speedCalibration & get_calibration( size_t index ) const { return m_calibration.get( index ); } // For read access
    LMX_GDECL lmx::elmx_error append_calibration() { return append_calibration( new c_speedCalibration ); }               // For write access
    LMX_GDECL lmx::elmx_error append_calibration( c_speedCalibration * p_value ) // For write access
    {
        lmx::uniq_ptr< c_speedCalibration >::type auto_p_value( p_value );
        m_calibration.append( auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_speedCalibration & back_calibration() { return m_calibration.back(); }            // For write access
    LMX_GDECL lmx::elmx_error insert_calibration( size_t index ) { return insert_calibration( index, new c_speedCalibration ); } // For write access
    LMX_GDECL lmx::elmx_error insert_calibration( size_t index, c_speedCalibration * p_value ) // For write access
    {
        lmx::uniq_ptr< c_speedCalibration >::type auto_p_value( p_value );
        m_calibration.insert( index, auto_p_value );
        return lmx::ELMX_OK;
    }
    LMX_GDECL c_speedCalibration & get_calibration( size_t index ) { return m_calibration.get( index ); } // For read/write access
    LMX_GDECL void delete_calibration( size_t index )
    {
        lmx_assert( index < m_calibration.size() );
        m_calibration.erase( index );
    }
    LMX_GDECL void clear_calibration() { m_calibration.clear(); }
    LMX_GDECL c_speedCalibration & assign_calibration( size_t index, const c_speedCalibration & value ) { return get_calibration( index ) = value; } // Deep Copy
    LMX_GDECL c_speedCalibration & assign_calibration( size_t index, c_speedCalibration * p ) { return m_calibration.assign( index, p ); }
    LMX_GDECL size_t size_calibration() const { return m_calibration.size(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "massCalibration" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "massCalibration" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_3( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_4( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_5( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_6( const lmx::tlmx_double &, const char * );
#endif // LMX_USER_VALIDATE

// From: TuneParameters.xsd(12)
class c_CmsTuneParametersType
{
    //:snippet:start CmsTuneParametersType
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end CmsTuneParametersType

private:
    // Element(s)
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_extractionElectrode;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_hexapoleBias;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_hexapoleRF;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_hexapoleRFDynamic;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_ionEnergy;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_ionEnergyDynamic;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_resolutionOffset;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_resolutionGain;
    lmx::ct_simple_pod_single< lmx::tlmx_double > m_detector;
    lmx::ct_complex_optional< c_calibration > m_calibration;
    lmx::ct_complex_optional< c_massCalibration > m_massCalibration;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_CmsTuneParametersType();
    LMX_GDECL c_CmsTuneParametersType( const c_CmsTuneParametersType & r_rhs );
    LMX_GDECL c_CmsTuneParametersType & operator = ( const c_CmsTuneParametersType & r_rhs );
    LMX_GDECL virtual c_CmsTuneParametersType * clone() const;
    LMX_GDECL void swap( c_CmsTuneParametersType & r_rhs );
    LMX_GDECL virtual ~c_CmsTuneParametersType();

    // Element(s)

    //    extractionElectrode --> xs:double{0<=x<=10} (Default: 0)
    LMX_GDECL const lmx::tlmx_double & get_extractionElectrode() const { return m_extractionElectrode.get(); }
    LMX_GDECL lmx::elmx_error set_extractionElectrode( const lmx::tlmx_double & value );

    //    hexapoleBias --> xs:double{-10<=x<=10} (Default: 0)
    LMX_GDECL const lmx::tlmx_double & get_hexapoleBias() const { return m_hexapoleBias.get(); }
    LMX_GDECL lmx::elmx_error set_hexapoleBias( const lmx::tlmx_double & value );

    //    hexapoleRF --> xs:double{0<=x<=250} (Default: 0)
    LMX_GDECL const lmx::tlmx_double & get_hexapoleRF() const { return m_hexapoleRF.get(); }
    LMX_GDECL lmx::elmx_error set_hexapoleRF( const lmx::tlmx_double & value );

    //    hexapoleRFDynamic --> xs:double{0<=x<=250} (Default: 0)
    LMX_GDECL const lmx::tlmx_double & get_hexapoleRFDynamic() const { return m_hexapoleRFDynamic.get(); }
    LMX_GDECL lmx::elmx_error set_hexapoleRFDynamic( const lmx::tlmx_double & value );

    //    ionEnergy --> xs:double{-10<=x<=10} (Default: 0)
    LMX_GDECL const lmx::tlmx_double & get_ionEnergy() const { return m_ionEnergy.get(); }
    LMX_GDECL lmx::elmx_error set_ionEnergy( const lmx::tlmx_double & value );

    //    ionEnergyDynamic --> xs:double{-10<=x<=10} (Default: 0)
    LMX_GDECL const lmx::tlmx_double & get_ionEnergyDynamic() const { return m_ionEnergyDynamic.get(); }
    LMX_GDECL lmx::elmx_error set_ionEnergyDynamic( const lmx::tlmx_double & value );

    //    resolutionOffset --> xs:double{-10<=x<=10} (Default: 0)
    LMX_GDECL const lmx::tlmx_double & get_resolutionOffset() const { return m_resolutionOffset.get(); }
    LMX_GDECL lmx::elmx_error set_resolutionOffset( const lmx::tlmx_double & value );

    //    resolutionGain --> xs:double{-10<=x<=10} (Default: 0)
    LMX_GDECL const lmx::tlmx_double & get_resolutionGain() const { return m_resolutionGain.get(); }
    LMX_GDECL lmx::elmx_error set_resolutionGain( const lmx::tlmx_double & value );

    //    detector --> xs:double{0<=x<=2800} (Default: 0)
    LMX_GDECL const lmx::tlmx_double & get_detector() const { return m_detector.get(); }
    LMX_GDECL lmx::elmx_error set_detector( const lmx::tlmx_double & value );

    //    calibration --> calibration[0..1]
    LMX_GDECL const c_calibration & get_calibration() const { return m_calibration.get(); }
    LMX_GDECL c_calibration & get_calibration() { return m_calibration.get(); } // For read/write access
    LMX_GDECL c_calibration & assign_calibration( const c_calibration & value ) { return (get_calibration() = value); }
    LMX_GDECL c_calibration & assign_calibration( c_calibration * p ) { return m_calibration.assign( p ); }
    LMX_GDECL bool isset_calibration() const { return m_calibration.is_value_set(); }
    LMX_GDECL void unset_calibration() { m_calibration.unset(); }

    //    massCalibration --> massCalibration[0..1]
    LMX_GDECL const c_massCalibration & get_massCalibration() const { return m_massCalibration.get(); }
    LMX_GDECL c_massCalibration & get_massCalibration() { return m_massCalibration.get(); } // For read/write access
    LMX_GDECL c_massCalibration & assign_massCalibration( const c_massCalibration & value ) { return (get_massCalibration() = value); }
    LMX_GDECL c_massCalibration & assign_massCalibration( c_massCalibration * p ) { return m_massCalibration.assign( p ); }
    LMX_GDECL bool isset_massCalibration() const { return m_massCalibration.is_value_set(); }
    LMX_GDECL void unset_massCalibration() { m_massCalibration.unset(); }

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "CmsTuneParametersType" ) const;

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "CmsTuneParametersType" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & LMX_UNUSED_PARAM(r_writer) ) const {}
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

#ifdef LMX_USER_VALIDATE
lmx::elmx_error user_validator_7( const lmx::tlmx_unicode_string &, const char * );
#endif // LMX_USER_VALIDATE

// From: TuneParameters.xsd(3)
class c_tuneParameters : public c_CmsTuneParametersType
{
    //:snippet:start tuneParameters
    bool on_lmx_is_occurs_ok() const { return true; }
    //:snippet:end tuneParameters

private:
    // Attribute(s)
    lmx::ct_simple_non_pod_optional< lmx::tlmx_unicode_string > m_version;

    static const lmx::s_event_map attr_event_map[];
    static const lmx::s_event_map elem_event_map[];
    static const lmx::s_known_elements known_elements[];

public:
    LMX_GDECL c_tuneParameters();
    LMX_GDECL c_tuneParameters( const c_tuneParameters & r_rhs );
    LMX_GDECL c_tuneParameters & operator = ( const c_tuneParameters & r_rhs );
    LMX_GDECL virtual c_tuneParameters * clone() const;
    LMX_GDECL void swap( c_tuneParameters & r_rhs );
    LMX_GDECL c_tuneParameters( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    // Convenience constructors
    LMX_GDECL c_tuneParameters( const char c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL c_tuneParameters( const wchar_t c_file_name[], lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL c_tuneParameters( const char * p_memory, size_t memory_size, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_tuneParameters( const std::string & r_string, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL c_tuneParameters( const lmx::c_any_info & r_any_info, lmx::elmx_error * p_error, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL virtual ~c_tuneParameters();

    // Attribute(s)

    //    version --> xs:string[0..1] (Default: 1.3)
    LMX_GDECL const lmx::tlmx_unicode_string & get_version() const { return m_version.get(); }
    LMX_GDECL lmx::elmx_error set_version( const lmx::tlmx_unicode_string & value ) { return m_version.set( value ); }
    LMX_GDECL bool isset_version() const { return m_version.is_value_set(); }
    LMX_GDECL void unset_version();
    // Element(s)

    LMX_GDECL bool is_occurs_ok( lmx::c_check_tracker * p_tracker_in = LMXNULL ) const;

    LMX_GDECL bool check( lmx::c_check_tracker * p_tracker_in = LMXNULL, const char * p_name_in = "tuneParameters" ) const;

    LMX_GDECL static const lmx::s_ns_map * ns_map() { return TuneParameters_reader; }
    // Convenience marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #if defined( _MSC_VER ) && _MSC_VER >= 1400
        LMX_GDECL lmx::elmx_error marshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    #endif
    LMX_GDECL lmx::elmx_error marshal( std::string * p_string, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error marshal( std::ostream & r_sos, lmx::s_debug_error * p_debug_error = LMXNULL ) const;
    LMX_GDECL lmx::elmx_error unmarshal( const char c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #if LMX_WANT_WIDE_FILE_NAMES == 1
        LMX_GDECL lmx::elmx_error unmarshal( const wchar_t c_file_name[], lmx::s_debug_error * p_debug_error = LMXNULL );
    #endif
    LMX_GDECL lmx::elmx_error unmarshal( const char * p_memory, size_t memory_size, lmx::s_debug_error * p_debug_error = LMXNULL );
    LMX_GDECL lmx::elmx_error unmarshal( const std::string & r_string, lmx::s_debug_error * p_debug_error = LMXNULL )
    {
        return unmarshal( r_string.data(), r_string.size(), p_debug_error );
    }
    LMX_GDECL lmx::elmx_error unmarshal( const lmx::c_any_info & r_any_info, lmx::s_debug_error * p_debug_error = LMXNULL );

    // General marshal/unmarshal functions
    LMX_GDECL lmx::elmx_error marshal( lmx::c_xml_writer & r_writer, const char * p_name = "tuneParameters" ) const;
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader );
    LMX_GDECL lmx::elmx_error unmarshal( lmx::c_xml_reader & r_reader, const std::string & r_name );
    LMX_GDECL void reset();

protected:
    LMX_GDECL void marshal_attributes( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL lmx::elmx_error marshal_child_elements( lmx::c_xml_writer & r_writer ) const;
    LMX_GDECL bool unmarshal_attributes( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );
    LMX_GDECL lmx::elmx_error unmarshal_attributes_check( lmx::c_xml_reader & r_reader );
    LMX_GDECL bool unmarshal_body( lmx::c_xml_reader & r_reader, lmx::elmx_error * p_error );

private:
    LMX_GDECL void init();
    LMX_GDECL void release();
};

}   // end of namespace AdvionObjects

#if defined( _MSC_VER ) && _MSC_VER >= 1400
#pragma warning (pop)  // Restore disabled warnings
#endif


#endif      // End of include guard
